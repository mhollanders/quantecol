<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dr.&nbsp;Matthijs Hollanders">
<meta name="dcterms.date" content="2025-02-04">

<title>Quantecol - Marginalisation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../img/Icon-Quantecol-RGB-FA-1-500.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Quantecol - Marginalisation">
<meta property="og:description" content="">
<meta property="og:image" content="https://quantecol.com.au/img/marg.png">
<meta property="og:site-name" content="Quantecol">
<meta property="og:image:height" content="700">
<meta property="og:image:width" content="1166">
<meta name="twitter:title" content="Quantecol - Marginalisation">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://quantecol.com.au/img/marg.png">
<meta name="twitter:image-height" content="700">
<meta name="twitter:image-width" content="1166">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../img/Logo-Quantecol-RGB-FA-2-1000.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../services.html" rel="" target="">
 <span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../portfolio.html" rel="" target="">
 <span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../about/vision.html" rel="" target="">
 <span class="dropdown-text">Our Vision</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../about/people/matthijs.html" rel="" target="">
 <span class="dropdown-text">People</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../about/contact.html" rel="" target="">
 <span class="dropdown-text">Contact Us</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/realQuantecol" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#occupancy-models" id="toc-occupancy-models" class="nav-link" data-scroll-target="#occupancy-models">Occupancy models</a>
  <ul class="collapse">
  <li><a href="#general-approach" id="toc-general-approach" class="nav-link" data-scroll-target="#general-approach">General approach</a></li>
  <li><a href="#multinomial-likelihood" id="toc-multinomial-likelihood" class="nav-link" data-scroll-target="#multinomial-likelihood">Multinomial likelihood</a></li>
  </ul></li>
  <li><a href="#n-mixture-models" id="toc-n-mixture-models" class="nav-link" data-scroll-target="#n-mixture-models"><em>N</em>-mixture models</a>
  <ul class="collapse">
  <li><a href="#combining-occupancy-and-abundance" id="toc-combining-occupancy-and-abundance" class="nav-link" data-scroll-target="#combining-occupancy-and-abundance">Combining occupancy and abundance</a></li>
  <li><a href="#time-to-event-n-mixture-model" id="toc-time-to-event-n-mixture-model" class="nav-link" data-scroll-target="#time-to-event-n-mixture-model">Time-to-event <em>N</em>-mixture model</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Marginalising discrete variables in ecological models</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p><a href="../about/people/matthijs.html">Dr.&nbsp;Matthijs Hollanders</a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 4, 2025</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Bayesian methods are popular for ecological modeling because of the flexibility afforded by software like JAGS, NIMBLE, and Stan. JAGS and NIMBLE are derivatives of the BUGS (Bayesian inference Using Gibbs Sampling) language and, unlike Stan, permit discrete parameters. Discrete parameters are common in <em>conditional likelihood</em> parameterisations of many ecological models, such as the alive state in mark-recapture, occupancy in occupancy models, and abundance in <em>N</em>-mixture models. All of these models can be expressed in the <em>marginal likelihood</em> form where the likelihood is expressed without the discrete parameters, effectively integrating over the possible values of each parameter.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Marginal and conditional likelihoods
</div>
</div>
<div class="callout-body-container callout-body">
<p>When we speak about conditional likelihoods in the context of ecological models, we express the likelihood of the data <span class="math inline">\(y\)</span> as a function of parameters <span class="math inline">\(\theta\)</span> and (partially) hidden discrete states <span class="math inline">\(Z\)</span>, denoted <span class="math inline">\(\mathcal{L}_c(y \mid \theta, Z)\)</span>. The marginal likelihood expresses the same likelihood without the discrete states, thus <em>marginalising</em> them from the model, <span class="math inline">\(\mathcal{L}_m(y \mid \theta)\)</span></p>
</div>
</div>
<p>Marginalisation leads to faster estimation and, ironically, better exploration of the posterior distributions of the underlying discrete states compared to sampling them directly. The downside is that these models can be more difficult to code or understand, because the marginal likelihood parameterisations don’t reflect the data-generating process as closely as the conditional parameterisations. Ironically, all of these ecological models were first constructed in the marginalised form when frequentist methods dominated the field. Although the conditional parameterisations facilitated the on-boarding of many ecologists that were less stats-savvy (like myself), generally the marginalised forms should be preferred. And when using gradient-based MCMC methods such as the No U-Turn Sampler (NUTS) implemented in Stan, you don’t have a choice.</p>
<p>When I became interested in statistics during my PhD I was using JAGS and subsequently NIMBLE. I always knew I wanted to learn Stan but I found the marginalisation of discrete parameters daunting. Once I decided to bite the bullet, I quickly realised it wasn’t so hard, and it culminated in my <a href="../blog/hmm-in-stan.html">first blog post</a> about implementing hidden Markov models in Stan. In this post, I’ll focus on two types of popular models that are generally not constructed as hidden Markov models: occupancy and <em>N</em>-mixture models. I’ll show how to quickly marginalise the latent states, how to recover posterior distributions for them after estimation, and explore different parameterisations and model types.</p>
</section>
<section id="occupancy-models" class="level1">
<h1>Occupancy models</h1>
<p>The data-generating process of an occupancy model is assumed to be as follows, where sites <span class="math inline">\(i \in 1:I\)</span> are either occupied by a species (<span class="math inline">\(z = 1\)</span>) or not (<span class="math inline">\(z = 0\)</span>) determined by occupancy probability <span class="math inline">\(\psi\)</span>, and subsequently detected (<span class="math inline">\(y = 1\)</span>) or not (<span class="math inline">\(y = 0\)</span>) during replicate survey <span class="math inline">\(j \in 1:J_i\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> with detection probability <span class="math inline">\(p\)</span> <span class="citation" data-cites="mackenzie2002">(<a href="#ref-mackenzie2002" role="doc-biblioref">MacKenzie et al. 2002</a>)</span>:</p>
<p><span id="eq-occ"><span class="math display">\[
\begin{aligned}
z_i &amp;\sim \textrm{Bernoulli} (\psi) \\
y_{ij} &amp;\sim \textrm{Bernoulli} (z_i \cdot p)
\end{aligned}
\tag{1}\]</span></span></p>
<p>The conditional likelihood for each site’s detection history (where <span class="math inline">\(\boldsymbol{y}_i\)</span> is the detection history of each site consisting of 1s and 0s) is expressed as follows:</p>
<p><span id="eq-occ-c"><span class="math display">\[
\mathcal{L}_c(\boldsymbol{y}_i \mid \psi, p, z_i) = \textrm{Bernoulli}(z_i \mid \psi) \cdot \prod_{j=1}^{J_i}\textrm{Bernoulli}(y_{ij} \mid z_i \cdot p)
\tag{2}\]</span></span></p>
<p>Here, the discrete occupancy states <span class="math inline">\(z_i\)</span> are partially unknown<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> and often a quantity of interest in addition to the two parameters governing the model, <span class="math inline">\(\psi\)</span> and <span class="math inline">\(p\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> The marginal likelihood is expressed as follows:</p>
<p><span id="eq-occ-m"><span class="math display">\[
\begin{aligned}
\mathcal{L}_m(\boldsymbol{y}_i \mid \psi, p) &amp;= \sum_{z = 0}^1 \left[ \textrm{Bernoulli}(z \mid \psi) \cdot \prod_{j=1}^{J_i}\textrm{Bernoulli}(y_{ij} \mid z \cdot p) \right] \\
&amp;= \textrm{Bernoulli}(0 \mid \psi) \cdot \prod_{j=1}^{J_i}\textrm{Bernoulli}(y_{ij} \mid 0 \cdot p) \\
&amp;\quad \ + \textrm{Bernoulli}(1 \mid \psi) \cdot \prod_{j=1}^{J_i}\textrm{Bernoulli}(y_{ij} \mid 1 \cdot p) \\
\end{aligned}
\tag{3}\]</span></span></p>
<p>which can simplified by recognising that <span class="math inline">\(z_i\)</span> is known when any detections are made (we know the site is occupied) and that we only need to marginalise over the two states when no detections are made, because the site could still be occupied. Therefore, <a href="#eq-occ-m">Equation&nbsp;3</a> simplifies as follows, where <span class="math inline">\(Q_i = \sum_{j = 1}^{J_i} y_{ij}\)</span>:</p>
<p><span id="eq-occ-m2"><span class="math display">\[
\mathcal{L}_m(\boldsymbol{y}_i \mid \psi, p) = \begin{cases}
\psi \cdot \prod_{j=1}^{J_i} \textrm{Bernoulli}(y_{ij} \mid p), &amp;Q_i &gt; 0, \\
1 - \psi + \psi \cdot \prod_{j=1}^{J_i} \textrm{Bernoulli}(0 \mid p), &amp;Q_i = 0,
\end{cases}
\tag{4}\]</span></span></p>
<p>Note that the first term in the second line is just <span class="math inline">\(1 - \psi\)</span> because <span class="math inline">\(\prod_{j=1}^{J_i}\textrm{Bernoulli}(y_{ij} \mid 0) = 0\)</span> if any detections are made. If we assume constant detection probabilities across surveys within a site, this can be further simplified by adopting a Binomial distribution as follows:</p>
<p><span id="eq-occ-b"><span class="math display">\[
\mathcal{L}_m(\boldsymbol{y}_i \mid \psi, p) = \begin{cases}
\psi \cdot \textrm{Binomial}(Q_i \mid J_i, p), &amp;Q_i &gt; 0, \\
1 - \psi + \psi \cdot \textrm{Binomial}(0 \mid J_i, p), &amp;Q_i = 0,
\end{cases}
\tag{5}\]</span></span></p>
<p>If this isn’t making much sense yet (it didn’t to me the first few times I tried), take a look at the Stan program below. I’ll first simulate some occupancy data, where all sites have the same number of surveys.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># parameters</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">set.seed</span>(<span class="dv">2025</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a>I <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>J_max <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>J <span class="ot">&lt;-</span> <span class="fu">rep</span>(J_max, I)</span>
<span id="cb1-6"><a href="#cb1-6"></a>psi <span class="ot">&lt;-</span> <span class="fl">0.6</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>p <span class="ot">&lt;-</span> <span class="fl">0.4</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"># simulate</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>z <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(I, <span class="dv">1</span>, psi)</span>
<span id="cb1-11"><a href="#cb1-11"></a>y <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, I, J_max)</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb1-13"><a href="#cb1-13"></a>  y[i, <span class="dv">1</span><span class="sc">:</span>J[i]] <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(J[i], <span class="dv">1</span>, z[i] <span class="sc">*</span> p)</span>
<span id="cb1-14"><a href="#cb1-14"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="general-approach" class="level2">
<h2 class="anchored" data-anchor-id="general-approach">General approach</h2>
<p>The first approach I outline follows <a href="#eq-occ-m2">Equation&nbsp;4</a> and computes the site-level log-likelihood in a for-loop. A few things to note about this and some upcoming programs:</p>
<ul>
<li>I’m using mostly flat or weakly informative priors.</li>
<li>When marginalising out discrete parameters, since we’re summing over the mutually exclusive probabilities, we have to keep track of our normalising constants. Therefore, we need to use the <code>_lpmf</code> instead of the <code>_lupmf</code> distributions. This doesn’t make a difference for the Bernoulli distribution because it doesn’t have constant terms, but it does for other examples.</li>
<li>Although I’ve just simulated data with fixed occupancy and detection probabilities, these models facilitate site-level effects on occupancy and site-by-occasion effects on detection. Therefore, in the <code>model</code> block, I created a vector of occupancy probabilities and a matrix of detection probabilities (using the “intercepts” <code>psi_a</code> and <code>p_a</code>) to guide practitioners using this as a template for their own models.</li>
<li>In the <code>model</code> block, since we specify a <em>log</em> probability density in Stan, I pre-compute <span class="math inline">\(\log(\psi)\)</span> and <span class="math inline">\(\log(1 - \psi)\)</span>, as this vectorised operation is more efficient than doing it for each site in the for-loop.</li>
<li>In the same vein, summing probabilities on the second line of <a href="#eq-occ-m">Equation&nbsp;3</a> equates to using the <code>log_sum_exp()</code> function in Stan when working with log probabilities.</li>
<li>In the <code>generated quantities</code> block, I recover the latent occupancy states that most likely generated the data. I initialise an array of ones (all sites occupied), but then for sites without detections I sort the log probabilities associated with each occupancy state and extract the most likely one, subtracting 1 from the index to yield 0s and 1s.</li>
</ul>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># load packages</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(pacman)) <span class="fu">install.packages</span>(<span class="st">"pacman"</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>pacman<span class="sc">::</span><span class="fu">p_load</span>(cmdstanr, loo, tidyverse, tidybayes, posterior)</span>
<span id="cb2-4"><a href="#cb2-4"></a>chains <span class="ot">&lt;-</span> <span class="dv">8</span> ; iter_warmup <span class="ot">&lt;-</span> <span class="dv">200</span> ; iter_sampling <span class="ot">&lt;-</span> <span class="dv">500</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="fu">options</span>(<span class="at">mc.cores =</span> chains)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-output.var="occ">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> {</span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I, J_max;  <span class="co">// number of sites and maximum surveys</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J_max&gt; J; <span class="co">// number of surveys</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="dt">array</span>[I, J_max] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; y;  <span class="co">// detection history</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>}</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">transformed data</span> {</span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> Q;  <span class="co">// number of detections</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb3-10"><a href="#cb3-10"></a>    Q[i] = sum(y[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb3-11"><a href="#cb3-11"></a>  }</span>
<span id="cb3-12"><a href="#cb3-12"></a>}</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="kw">parameters</span> {</span>
<span id="cb3-15"><a href="#cb3-15"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; psi_a, p_a;</span>
<span id="cb3-16"><a href="#cb3-16"></a>}</span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="kw">model</span> {</span>
<span id="cb3-19"><a href="#cb3-19"></a>  <span class="co">// priors</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>  <span class="kw">target +=</span> beta_lupdf(psi_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb3-21"><a href="#cb3-21"></a>  <span class="kw">target +=</span> beta_lupdf(p_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb3-22"><a href="#cb3-22"></a>  </span>
<span id="cb3-23"><a href="#cb3-23"></a>  <span class="co">// site-level occupancy and site-by-occasion level detection</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>  <span class="dt">vector</span>[I] psi = rep_vector(psi_a, I);</span>
<span id="cb3-25"><a href="#cb3-25"></a>  <span class="dt">matrix</span>[I, J_max] p = rep_matrix(p_a, I, J_max);</span>
<span id="cb3-26"><a href="#cb3-26"></a>  </span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="co">// log-transform occupancy probabilities</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>  <span class="dt">vector</span>[I] log_psi = log(psi), log1m_psi = log1m(psi);</span>
<span id="cb3-29"><a href="#cb3-29"></a>  </span>
<span id="cb3-30"><a href="#cb3-30"></a>  <span class="co">// likelihood</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb3-32"><a href="#cb3-32"></a>    <span class="cf">if</span> (Q[i]) {</span>
<span id="cb3-33"><a href="#cb3-33"></a>      <span class="kw">target +=</span> log_psi[i] + bernoulli_lpmf(y[i, <span class="dv">1</span>:J[i]] | p[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb3-34"><a href="#cb3-34"></a>    } <span class="cf">else</span> {</span>
<span id="cb3-35"><a href="#cb3-35"></a>      <span class="kw">target +=</span> log_sum_exp(log1m_psi[i], </span>
<span id="cb3-36"><a href="#cb3-36"></a>                            log_psi[i] + bernoulli_lpmf(y[i, <span class="dv">1</span>:J[i]] | p[i, <span class="dv">1</span>:J[i]]));</span>
<span id="cb3-37"><a href="#cb3-37"></a>    }</span>
<span id="cb3-38"><a href="#cb3-38"></a>  }</span>
<span id="cb3-39"><a href="#cb3-39"></a>}</span>
<span id="cb3-40"><a href="#cb3-40"></a></span>
<span id="cb3-41"><a href="#cb3-41"></a><span class="kw">generated quantities</span> {</span>
<span id="cb3-42"><a href="#cb3-42"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb3-43"><a href="#cb3-43"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> z = ones_int_array(I);</span>
<span id="cb3-44"><a href="#cb3-44"></a>  {</span>
<span id="cb3-45"><a href="#cb3-45"></a>    <span class="dt">vector</span>[I] psi = rep_vector(psi_a, I);</span>
<span id="cb3-46"><a href="#cb3-46"></a>    <span class="dt">matrix</span>[I, J_max] p = rep_matrix(p_a, I, J_max);</span>
<span id="cb3-47"><a href="#cb3-47"></a>    <span class="dt">vector</span>[I] log_psi = log(psi), log1m_psi = log1m(psi);</span>
<span id="cb3-48"><a href="#cb3-48"></a>    <span class="dt">row_vector</span>[<span class="dv">2</span>] lp;</span>
<span id="cb3-49"><a href="#cb3-49"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb3-50"><a href="#cb3-50"></a>      <span class="cf">if</span> (Q[i]) {</span>
<span id="cb3-51"><a href="#cb3-51"></a>        log_lik[i] = log_psi[i] + bernoulli_lpmf(y[i, <span class="dv">1</span>:J[i]] | p[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb3-52"><a href="#cb3-52"></a>      } <span class="cf">else</span> {</span>
<span id="cb3-53"><a href="#cb3-53"></a>        lp = [ log1m_psi[i], </span>
<span id="cb3-54"><a href="#cb3-54"></a>               log_psi[i] + bernoulli_lpmf(y[i, <span class="dv">1</span>:J[i]] | p[i, <span class="dv">1</span>:J[i]]) ];</span>
<span id="cb3-55"><a href="#cb3-55"></a>        log_lik[i] = log_sum_exp(lp);</span>
<span id="cb3-56"><a href="#cb3-56"></a>        z[i] = sort_indices_desc(lp)[<span class="dv">1</span>] - <span class="dv">1</span>;</span>
<span id="cb3-57"><a href="#cb3-57"></a>      }</span>
<span id="cb3-58"><a href="#cb3-58"></a>    }</span>
<span id="cb3-59"><a href="#cb3-59"></a>  }</span>
<span id="cb3-60"><a href="#cb3-60"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s run the model using <strong>cmdstanr</strong> <span class="citation" data-cites="gabry2024">(<a href="#ref-gabry2024" role="doc-biblioref">Gabry et al. 2024</a>)</span>. This samples well and fast, so we’ll run many iterations to compare speed.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>fit_occ <span class="ot">&lt;-</span> occ<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="at">data =</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J_max =</span> J_max, <span class="at">J =</span> J, <span class="at">y =</span> y), </span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> chains, </span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="at">iter_warmup =</span> <span class="fl">1e3</span>, <span class="at">iter_sampling =</span> <span class="fl">1e4</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...

Chain 1 finished in 2.4 seconds.
Chain 2 finished in 2.5 seconds.
Chain 3 finished in 2.5 seconds.
Chain 4 finished in 2.4 seconds.
Chain 5 finished in 2.5 seconds.
Chain 8 finished in 2.5 seconds.
Chain 6 finished in 2.7 seconds.
Chain 7 finished in 2.8 seconds.

All 8 chains finished successfully.
Mean chain execution time: 2.5 seconds.
Total execution time: 2.9 seconds.</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>fit_occ<span class="sc">$</span><span class="fu">summary</span>(<span class="fu">c</span>(<span class="st">"psi_a"</span>, <span class="st">"p_a"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="fu">select</span>(variable, median, <span class="fu">contains</span>(<span class="st">"q"</span>), rhat, <span class="fu">contains</span>(<span class="st">"ess"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(psi, p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 8
  variable median    q5   q95  rhat ess_bulk ess_tail truth
  &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
1 psi_a     0.656 0.520 0.834  1.00   25715.   21924.   0.6
2 p_a       0.346 0.260 0.436  1.00   23358.   28993.   0.4</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>fit_occ<span class="sc">$</span><span class="fu">loo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Computed from 80000 by 100 log-likelihood matrix.

         Estimate   SE
elpd_loo   -158.8 10.4
p_loo         1.9  0.2
looic       317.6 20.8
------
MCSE of elpd_loo is 0.0.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.3, 0.8]).

All Pareto k estimates are good (k &lt; 0.7).
See help('pareto-k-diagnostic') for details.</code></pre>
</div>
</div>
<p>We can also check the proportion of sites that had the latent occupancy estimated correctly. Not too bad.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="fu">mean</span>(fit_occ<span class="sc">$</span><span class="fu">summary</span>(<span class="st">"z"</span>)<span class="sc">$</span>median <span class="sc">==</span> z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.9</code></pre>
</div>
</div>
</section>
<section id="multinomial-likelihood" class="level2">
<h2 class="anchored" data-anchor-id="multinomial-likelihood">Multinomial likelihood</h2>
<p>There’s quicker ways to fit the same model, specifically with this intercepts-only model with the same number of surveys per site. This uses the multinomial likelihood by specifying cell probabilities for the possible detection histories, for which I’ll show the Stan program below. This approach leverages the definition that the number of surveys with detections follows a <span class="math inline">\(\textrm{Binomial}(J, p)\)</span> distribution and that sites have a finite number of possible detection histories.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> We can use the <code>multinomial_logit_lupmf</code> function to increment the log density after normalising the cell probabilities on the log scale.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="cell" data-output.var="occ_multi">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> {</span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I, J;  <span class="co">// number of sites and surveys</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; y;  <span class="co">// detection history</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>}</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="kw">transformed data</span> {</span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> Q;  <span class="co">// number of detections</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb12-9"><a href="#cb12-9"></a>    Q[i] = sum(y[i]);</span>
<span id="cb12-10"><a href="#cb12-10"></a>  }</span>
<span id="cb12-11"><a href="#cb12-11"></a>  <span class="dt">int</span> K = J + <span class="dv">1</span>;  <span class="co">// number of possible detection histories</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>  <span class="dt">array</span>[K] <span class="dt">int</span> P = zeros_int_array(K);  <span class="co">// category counts</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb12-14"><a href="#cb12-14"></a>    P[Q[i] + <span class="dv">1</span>] += <span class="dv">1</span>;</span>
<span id="cb12-15"><a href="#cb12-15"></a>  }</span>
<span id="cb12-16"><a href="#cb12-16"></a>}</span>
<span id="cb12-17"><a href="#cb12-17"></a></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="kw">parameters</span> {</span>
<span id="cb12-19"><a href="#cb12-19"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; psi_a, p_a;</span>
<span id="cb12-20"><a href="#cb12-20"></a>}</span>
<span id="cb12-21"><a href="#cb12-21"></a></span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="kw">model</span> {</span>
<span id="cb12-23"><a href="#cb12-23"></a>  <span class="co">// priors</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>  <span class="kw">target +=</span> beta_lupdf(psi_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb12-25"><a href="#cb12-25"></a>  <span class="kw">target +=</span> beta_lupdf(p_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb12-26"><a href="#cb12-26"></a>  </span>
<span id="cb12-27"><a href="#cb12-27"></a>  <span class="co">// log probabilities with detections</span></span>
<span id="cb12-28"><a href="#cb12-28"></a>  <span class="dt">vector</span>[K] lp = rep_vector(log(psi_a), K);</span>
<span id="cb12-29"><a href="#cb12-29"></a>  <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb12-30"><a href="#cb12-30"></a>    lp[k] += binomial_lpmf(k - <span class="dv">1</span> | J, p_a);</span>
<span id="cb12-31"><a href="#cb12-31"></a>  }</span>
<span id="cb12-32"><a href="#cb12-32"></a>  </span>
<span id="cb12-33"><a href="#cb12-33"></a>  <span class="co">// log probability without detections</span></span>
<span id="cb12-34"><a href="#cb12-34"></a>  lp[<span class="dv">1</span>] = log_sum_exp(log1m(psi_a), lp[<span class="dv">1</span>]);</span>
<span id="cb12-35"><a href="#cb12-35"></a>  </span>
<span id="cb12-36"><a href="#cb12-36"></a>  <span class="co">// increment target</span></span>
<span id="cb12-37"><a href="#cb12-37"></a>  <span class="kw">target +=</span> multinomial_logit_lupmf(P | lp - log_sum_exp(lp));</span>
<span id="cb12-38"><a href="#cb12-38"></a>}</span>
<span id="cb12-39"><a href="#cb12-39"></a></span>
<span id="cb12-40"><a href="#cb12-40"></a><span class="kw">generated quantities</span> {</span>
<span id="cb12-41"><a href="#cb12-41"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb12-42"><a href="#cb12-42"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> z = ones_int_array(I);</span>
<span id="cb12-43"><a href="#cb12-43"></a>  {</span>
<span id="cb12-44"><a href="#cb12-44"></a>    <span class="dt">real</span> log_psi = log(psi_a), log1m_psi = log1m(psi_a);</span>
<span id="cb12-45"><a href="#cb12-45"></a>    <span class="dt">row_vector</span>[<span class="dv">2</span>] lp;</span>
<span id="cb12-46"><a href="#cb12-46"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb12-47"><a href="#cb12-47"></a>      <span class="cf">if</span> (Q[i]) {</span>
<span id="cb12-48"><a href="#cb12-48"></a>        log_lik[i] = log_psi + bernoulli_lpmf(y[i] | p_a);</span>
<span id="cb12-49"><a href="#cb12-49"></a>      } <span class="cf">else</span> {</span>
<span id="cb12-50"><a href="#cb12-50"></a>        lp = [ log1m_psi, log_psi + bernoulli_lpmf(y[i] | p_a) ];</span>
<span id="cb12-51"><a href="#cb12-51"></a>        log_lik[i] = log_sum_exp(lp);</span>
<span id="cb12-52"><a href="#cb12-52"></a>        z[i] = sort_indices_desc(lp)[<span class="dv">1</span>] - <span class="dv">1</span>;</span>
<span id="cb12-53"><a href="#cb12-53"></a>      }</span>
<span id="cb12-54"><a href="#cb12-54"></a>    }</span>
<span id="cb12-55"><a href="#cb12-55"></a>  }</span>
<span id="cb12-56"><a href="#cb12-56"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This runs even faster and of course recovers the same posterior. We still need the same computations as the first model in the <code>generated quantities</code> block if we want the site-level log-likelihood values and latent states.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>fit_occ_multi <span class="ot">&lt;-</span> occ_multi<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="at">data =</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J =</span> J_max, <span class="at">y =</span> y), </span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> chains, </span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="at">iter_warmup =</span> <span class="fl">1e3</span>, <span class="at">iter_sampling =</span> <span class="fl">1e4</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Chain 1 finished in 0.6 seconds.
Chain 2 finished in 0.6 seconds.
Chain 3 finished in 0.6 seconds.
Chain 4 finished in 0.6 seconds.
Chain 5 finished in 0.6 seconds.
Chain 6 finished in 0.6 seconds.
Chain 7 finished in 0.6 seconds.
Chain 8 finished in 0.6 seconds.

All 8 chains finished successfully.
Mean chain execution time: 0.6 seconds.
Total execution time: 0.9 seconds.</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="fu">loo_compare</span>(fit_occ<span class="sc">$</span><span class="fu">loo</span>(), fit_occ_multi<span class="sc">$</span><span class="fu">loo</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>       elpd_diff se_diff
model1 0.0       0.0    
model2 0.0       0.0    </code></pre>
</div>
</div>
<p>The approaches outlined so far works well for single season occupancy. For any flavour of multi-season (dynamic) occupancy models, you’re much better off implementing the scaleable forward algorithm I describe in detail in my <a href="../blog/hmm-in-stan.html">first post</a>.</p>
</section>
</section>
<section id="n-mixture-models" class="level1">
<h1><em>N</em>-mixture models</h1>
<p><em>N</em>-mixture models are a popular class of models to estimate species abundance <span class="math inline">\(N\)</span> while accounting for imperfect detection <span class="citation" data-cites="royle2004">(<a href="#ref-royle2004" role="doc-biblioref">Royle 2004</a>)</span>. The data-generating process of the model is as follows, where the abundance at sites <span class="math inline">\(i \in 1:I\)</span> assumes some non-negative discrete distribution (e.g., Poisson with expected abundance <span class="math inline">\(\lambda\)</span>) and the observed counts of individuals <span class="math inline">\(y\)</span> during surveys <span class="math inline">\(j \in 1:J_i\)</span> follow a Binomial distribution where the number of trials is the latent population size and the success probability is the per-individual detection probability:</p>
<p><span id="eq-N-dgp"><span class="math display">\[
\begin{aligned}
  N_i &amp;\sim \textrm{Poisson}(\lambda) \\
  y_{ij} &amp;\sim \textrm{Binomial}(N_i, p)
\end{aligned}
\tag{6}\]</span></span></p>
<p>The conditional likelihood of each site given its detection history of counts <span class="math inline">\(\boldsymbol{y}_i\)</span> is:</p>
<p><span id="eq-N-c"><span class="math display">\[
\begin{aligned}
\mathcal{L}_c(\boldsymbol{y}_i \mid \lambda, p, N_i) = \textrm{Poisson}(N_i \mid \lambda) \cdot \prod_{j=1}^{J_i} \textrm{Binomial}(y_{ij} \mid N_i, p)
\end{aligned}
\tag{7}\]</span></span></p>
<p>Unlike the occupancy example where we have just two possibilities to sum over (and only for sites without detections), in <em>N</em>-mixture models we have to marginalise over lots of values (the possible population sizes). We know for certain that the population sizes are <span class="math inline">\(N_i \geq \max(y_i)\)</span>, but we don’t know how large the population can be. In practice, we set a maximum population size <span class="math inline">\(K\)</span> to marginalise over to ease computational burden. <span class="math inline">\(K\)</span> should be large enough to exceed the maximum plausible population size but not much larger than that. Often, ecologists are dealing with populations that aren’t huge so it shouldn’t be a problem. In the case of very large population sizes, a normal approximation to the Poisson might be appropriate, which completely negates the need to marginalise when we treat the latent population size as continuous instead of discrete:</p>
<p><span id="eq-N-a"><span class="math display">\[
\begin{aligned}
  N_i &amp;\sim \textrm{Normal}(\lambda, \lambda) \\
  y_{ij} &amp;\sim \textrm{Normal}(N_i \cdot p, \sqrt{N_i \cdot p \cdot (1 - p)})
\end{aligned}
\tag{8}\]</span></span></p>
<p>However, we are here to marginalise. Just like in the occupancy example, we need to sum the probabilities associated with each population size in <span class="math inline">\(\max(y_i):K\)</span> given that these probabilities are mutually exclusive, yielding the following marginal likelihood for each site:</p>
<p><span id="eq-N-m"><span class="math display">\[
\mathcal{L}_m(\boldsymbol{y}_i \mid \lambda, p) = \sum_{k = \max(y_i)}^K \left[ \textrm{Poisson}(k \mid \lambda) \cdot \prod_{j=1}^{J_i} \textrm{Binomial}(y_{ij} \mid k, p) \right]
\tag{9}\]</span></span></p>
<p>Below is a Stan program for the marginalised <em>N</em>-mixture model after some data simulation. As in the occupancy model, I set up the code ready to use with site-level effects on expected abundance and site-by-survey effects on detection probabilities. In order to retrieve the latent population sizes, we first normalise the log probabilities associated with each of the possible population sizes and then sample from them using a categorical distribution.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># parameters</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>lambda <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>p <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co"># simulate</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>N <span class="ot">&lt;-</span> <span class="fu">rpois</span>(I, lambda)</span>
<span id="cb18-7"><a href="#cb18-7"></a>y <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, I, J_max)</span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb18-9"><a href="#cb18-9"></a>  y[i, <span class="dv">1</span><span class="sc">:</span>J[i]] <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(J[i], N[i], p)</span>
<span id="cb18-10"><a href="#cb18-10"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In this program we define <code>ks</code> in <code>transformed data</code> to be the number of population sizes to marginalise over for each site.</p>
<div class="cell" data-output.var="nmix">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">data</span> {</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I, J_max, K;  <span class="co">// number of sites and maximum surveys and population size</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J_max&gt; J;  <span class="co">// number of surveys</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>  <span class="dt">array</span>[I, J_max] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; y;  <span class="co">// detection history</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>}</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">transformed data</span> {</span>
<span id="cb19-8"><a href="#cb19-8"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> max_y, ks;  <span class="co">// maximum counts and number of population sizes</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb19-10"><a href="#cb19-10"></a>    max_y[i] = max(y[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb19-11"><a href="#cb19-11"></a>    ks[i] = K - max_y[i] + <span class="dv">1</span>;</span>
<span id="cb19-12"><a href="#cb19-12"></a>  }</span>
<span id="cb19-13"><a href="#cb19-13"></a>}</span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="kw">parameters</span> {</span>
<span id="cb19-16"><a href="#cb19-16"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; lambda_a;</span>
<span id="cb19-17"><a href="#cb19-17"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; p_a;</span>
<span id="cb19-18"><a href="#cb19-18"></a>}</span>
<span id="cb19-19"><a href="#cb19-19"></a></span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="kw">model</span> {</span>
<span id="cb19-21"><a href="#cb19-21"></a>  <span class="co">// priors</span></span>
<span id="cb19-22"><a href="#cb19-22"></a>  <span class="kw">target +=</span> exponential_lupdf(lambda_a | <span class="fl">0.01</span>);</span>
<span id="cb19-23"><a href="#cb19-23"></a>  <span class="kw">target +=</span> beta_lupdf(p_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb19-24"><a href="#cb19-24"></a>  </span>
<span id="cb19-25"><a href="#cb19-25"></a>  <span class="co">// site-level expected abundance and site-by-occasion level detection</span></span>
<span id="cb19-26"><a href="#cb19-26"></a>  <span class="dt">vector</span>[I] lambda = rep_vector(lambda_a, I);</span>
<span id="cb19-27"><a href="#cb19-27"></a>  <span class="dt">matrix</span>[I, J_max] p = rep_matrix(p_a, I, J_max);</span>
<span id="cb19-28"><a href="#cb19-28"></a>  </span>
<span id="cb19-29"><a href="#cb19-29"></a>  <span class="co">// likelihood</span></span>
<span id="cb19-30"><a href="#cb19-30"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb19-31"><a href="#cb19-31"></a>    <span class="dt">vector</span>[ks[i]] lp;</span>
<span id="cb19-32"><a href="#cb19-32"></a>    <span class="cf">for</span> (k <span class="cf">in</span> max_y[i]:K) {</span>
<span id="cb19-33"><a href="#cb19-33"></a>      lp[k - max_y[i] + <span class="dv">1</span>] = poisson_lpmf(k | lambda[i]) </span>
<span id="cb19-34"><a href="#cb19-34"></a>                             + binomial_lpmf(y[i, <span class="dv">1</span>:J[i]] | k, p[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb19-35"><a href="#cb19-35"></a>    }</span>
<span id="cb19-36"><a href="#cb19-36"></a>    <span class="kw">target +=</span> log_sum_exp(lp);</span>
<span id="cb19-37"><a href="#cb19-37"></a>  }</span>
<span id="cb19-38"><a href="#cb19-38"></a>}</span>
<span id="cb19-39"><a href="#cb19-39"></a></span>
<span id="cb19-40"><a href="#cb19-40"></a><span class="kw">generated quantities</span> {</span>
<span id="cb19-41"><a href="#cb19-41"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb19-42"><a href="#cb19-42"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> N;</span>
<span id="cb19-43"><a href="#cb19-43"></a>  {</span>
<span id="cb19-44"><a href="#cb19-44"></a>    <span class="dt">vector</span>[I] lambda = rep_vector(lambda_a, I);</span>
<span id="cb19-45"><a href="#cb19-45"></a>    <span class="dt">matrix</span>[I, J_max] p = rep_matrix(p_a, I, J_max);</span>
<span id="cb19-46"><a href="#cb19-46"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb19-47"><a href="#cb19-47"></a>      <span class="dt">vector</span>[ks[i]] lp;</span>
<span id="cb19-48"><a href="#cb19-48"></a>      <span class="cf">for</span> (k <span class="cf">in</span> max_y[i]:K) {</span>
<span id="cb19-49"><a href="#cb19-49"></a>        lp[k - max_y[i] + <span class="dv">1</span>] = poisson_lpmf(k | lambda[i]) </span>
<span id="cb19-50"><a href="#cb19-50"></a>                               + binomial_lpmf(y[i, <span class="dv">1</span>:J[i]] | k, p[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb19-51"><a href="#cb19-51"></a>      }</span>
<span id="cb19-52"><a href="#cb19-52"></a>      log_lik[i] = log_sum_exp(lp);</span>
<span id="cb19-53"><a href="#cb19-53"></a>      N[i] = categorical_logit_rng(lp - log_lik[i]) + max_y[i] - <span class="dv">1</span>;</span>
<span id="cb19-54"><a href="#cb19-54"></a>    }</span>
<span id="cb19-55"><a href="#cb19-55"></a>  }</span>
<span id="cb19-56"><a href="#cb19-56"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s try this model with setting <span class="math inline">\(K\)</span> to be intentionally small at first. We won’t look at our estimates for <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(p\)</span> but instead check out the posterior distributions of some latent population sizes alongside the truth (red crosses).</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>data_nmix <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J_max =</span> J_max, <span class="at">K =</span> <span class="fu">max</span>(y), <span class="at">J =</span> J, <span class="at">y =</span> y)</span>
<span id="cb20-2"><a href="#cb20-2"></a>fit_nmix <span class="ot">&lt;-</span> nmix<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb20-3"><a href="#cb20-3"></a>  <span class="at">data =</span> data_nmix, </span>
<span id="cb20-4"><a href="#cb20-4"></a>  <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> chains, </span>
<span id="cb20-5"><a href="#cb20-5"></a>  <span class="at">iter_warmup =</span> iter_warmup, <span class="at">iter_sampling =</span> iter_sampling</span>
<span id="cb20-6"><a href="#cb20-6"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...

Chain 1 finished in 1.1 seconds.
Chain 2 finished in 1.2 seconds.
Chain 5 finished in 1.1 seconds.
Chain 3 finished in 1.2 seconds.
Chain 4 finished in 1.3 seconds.
Chain 6 finished in 1.2 seconds.
Chain 7 finished in 1.2 seconds.
Chain 8 finished in 1.2 seconds.

All 8 chains finished successfully.
Mean chain execution time: 1.2 seconds.
Total execution time: 1.4 seconds.</code></pre>
</div>
</div>
<p>We see that the estimated abundance of several sites is pushed right up to <span class="math inline">\(K\)</span> which we set to the maximum count. This is an extreme example, but it illustrates the point that you can tell graphically when <span class="math inline">\(K\)</span> is too small as some posteriors will pile up at <span class="math inline">\(K\)</span>.</p>
<div class="cell" data-fig.asp="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>fit_nmix <span class="sc">|&gt;</span> </span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="fu">spread_rvars</span>(N[i]) <span class="sc">|&gt;</span> </span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="fu">left_join</span>(<span class="fu">tibble</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>I, <span class="at">truth =</span> N), <span class="at">by =</span> <span class="st">"i"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb22-4"><a href="#cb22-4"></a>  <span class="fu">filter</span>(i <span class="sc">&lt;=</span> <span class="dv">25</span>) <span class="sc">|&gt;</span> </span>
<span id="cb22-5"><a href="#cb22-5"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> truth, <span class="at">xdist =</span> N, <span class="at">y =</span> <span class="fu">factor</span>(i) <span class="sc">|&gt;</span> <span class="fu">fct_rev</span>())) <span class="sc">+</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> data_nmix<span class="sc">$</span>K, <span class="at">colour =</span> <span class="st">"red4"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>) <span class="sc">+</span> </span>
<span id="cb22-7"><a href="#cb22-7"></a>  <span class="fu">stat_pointinterval</span>(<span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span> </span>
<span id="cb22-8"><a href="#cb22-8"></a>  <span class="fu">geom_point</span>(<span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="sc">-</span><span class="fl">0.3</span>), <span class="at">colour =</span> <span class="st">"red4"</span>, <span class="at">shape =</span> <span class="st">"cross"</span>) <span class="sc">+</span> </span>
<span id="cb22-9"><a href="#cb22-9"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="fu">expression</span>(N), </span>
<span id="cb22-10"><a href="#cb22-10"></a>       <span class="at">y =</span> <span class="st">"Site"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="marginalisation_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Let’s try it again with a more reasonable value for <span class="math inline">\(K\)</span>. We can now clearly see that all of the posteriors are well away from <span class="math inline">\(K\)</span>, indicating <span class="math inline">\(K\)</span> was large enough for the approximation. The model does run much slower, highlighting the trade-off between a reasonable approximation and computational cost.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>data_nmix<span class="sc">$</span>K <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">max</span>(N)</span>
<span id="cb23-2"><a href="#cb23-2"></a>fit_nmix2 <span class="ot">&lt;-</span> nmix<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="at">data =</span> data_nmix, </span>
<span id="cb23-4"><a href="#cb23-4"></a>  <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> <span class="dv">8</span>, </span>
<span id="cb23-5"><a href="#cb23-5"></a>  <span class="at">iter_warmup =</span> iter_warmup, <span class="at">iter_sampling =</span> iter_sampling</span>
<span id="cb23-6"><a href="#cb23-6"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...

Chain 2 finished in 31.9 seconds.
Chain 5 finished in 33.1 seconds.
Chain 8 finished in 33.2 seconds.
Chain 7 finished in 34.5 seconds.
Chain 3 finished in 35.1 seconds.
Chain 1 finished in 35.2 seconds.
Chain 6 finished in 35.1 seconds.
Chain 4 finished in 38.0 seconds.

All 8 chains finished successfully.
Mean chain execution time: 34.5 seconds.
Total execution time: 38.2 seconds.</code></pre>
</div>
</div>
<div class="cell" data-fig.asp="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>fit_nmix2 <span class="sc">|&gt;</span> </span>
<span id="cb25-2"><a href="#cb25-2"></a>  <span class="fu">spread_rvars</span>(N[i]) <span class="sc">|&gt;</span> </span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="fu">left_join</span>(<span class="fu">tibble</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>I, <span class="at">truth =</span> N), <span class="at">by =</span> <span class="st">"i"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="fu">filter</span>(i <span class="sc">&lt;=</span> <span class="dv">25</span>) <span class="sc">|&gt;</span> </span>
<span id="cb25-5"><a href="#cb25-5"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> truth, <span class="at">xdist =</span> N, <span class="at">y =</span> <span class="fu">factor</span>(i) <span class="sc">|&gt;</span> <span class="fu">fct_rev</span>())) <span class="sc">+</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> data_nmix<span class="sc">$</span>K, <span class="at">colour =</span> <span class="st">"red4"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>) <span class="sc">+</span> </span>
<span id="cb25-7"><a href="#cb25-7"></a>  <span class="fu">stat_pointinterval</span>(<span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span> </span>
<span id="cb25-8"><a href="#cb25-8"></a>  <span class="fu">geom_point</span>(<span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="sc">-</span><span class="fl">0.3</span>), <span class="at">colour =</span> <span class="st">"red4"</span>, <span class="at">shape =</span> <span class="st">"cross"</span>) <span class="sc">+</span> </span>
<span id="cb25-9"><a href="#cb25-9"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="fu">expression</span>(N), </span>
<span id="cb25-10"><a href="#cb25-10"></a>       <span class="at">y =</span> <span class="st">"Site"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="marginalisation_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Unsurprisingly, our estimates for <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(p\)</span> were severely biased when <span class="math inline">\(K\)</span> is too small as indicated in the plot below, where the red crosses indicate the true values.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a><span class="fu">map</span>(<span class="fu">list</span>(fit_nmix, fit_nmix2), </span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="sc">~</span>(.x <span class="sc">|&gt;</span> </span>
<span id="cb26-3"><a href="#cb26-3"></a>        <span class="fu">gather_rvars</span>(lambda_a, p_a))) <span class="sc">|&gt;</span> </span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="fu">list_rbind</span>(<span class="at">names_to =</span> <span class="st">"model"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="fu">mutate</span>(<span class="at">model =</span> <span class="fu">factor</span>(model, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"Low"</span>, <span class="st">"Appropriate"</span>))) <span class="sc">|&gt;</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">xdist =</span> .value)) <span class="sc">+</span> </span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> <span class="fu">factor</span>(.variable, </span>
<span id="cb26-8"><a href="#cb26-8"></a>                      <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"lambda"</span>, <span class="st">"p"</span>)), </span>
<span id="cb26-9"><a href="#cb26-9"></a>             <span class="at">scales =</span> <span class="st">"free"</span>, </span>
<span id="cb26-10"><a href="#cb26-10"></a>             <span class="at">labeller =</span> label_parsed, </span>
<span id="cb26-11"><a href="#cb26-11"></a>             <span class="at">ncol =</span> <span class="dv">1</span>) <span class="sc">+</span> </span>
<span id="cb26-12"><a href="#cb26-12"></a>  <span class="fu">stat_pointinterval</span>(<span class="fu">aes</span>(<span class="at">linetype =</span> model, <span class="at">shape =</span> model), </span>
<span id="cb26-13"><a href="#cb26-13"></a>                     <span class="at">position =</span> <span class="fu">position_dodge</span>(<span class="at">width =</span> <span class="fl">0.2</span>), </span>
<span id="cb26-14"><a href="#cb26-14"></a>                     <span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">linewidth =</span> <span class="dv">1</span>) <span class="sc">+</span> </span>
<span id="cb26-15"><a href="#cb26-15"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> <span class="fu">tibble</span>(<span class="at">.variable =</span> <span class="fu">c</span>(<span class="st">"lambda_a"</span>, <span class="st">"p_a"</span>),</span>
<span id="cb26-16"><a href="#cb26-16"></a>                           <span class="at">.value =</span> <span class="fu">c</span>(lambda, p)),</span>
<span id="cb26-17"><a href="#cb26-17"></a>             <span class="fu">aes</span>(<span class="at">x =</span> .value, <span class="at">y =</span> <span class="dv">0</span>), </span>
<span id="cb26-18"><a href="#cb26-18"></a>             <span class="at">colour =</span> <span class="st">"red4"</span>, <span class="at">size =</span> <span class="dv">2</span>, <span class="at">shape =</span> <span class="st">"cross"</span>) <span class="sc">+</span> </span>
<span id="cb26-19"><a href="#cb26-19"></a>  ggeasy<span class="sc">::</span><span class="fu">easy_remove_y_axis</span>() <span class="sc">+</span> </span>
<span id="cb26-20"><a href="#cb26-20"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Posterior"</span>, </span>
<span id="cb26-21"><a href="#cb26-21"></a>       <span class="at">linetype =</span> <span class="st">"K"</span>,</span>
<span id="cb26-22"><a href="#cb26-22"></a>       <span class="at">shape =</span> <span class="st">"K"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="marginalisation_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<section id="combining-occupancy-and-abundance" class="level2">
<h2 class="anchored" data-anchor-id="combining-occupancy-and-abundance">Combining occupancy and abundance</h2>
<p>What if we’re counting individuals at sites but not all sites are occupied? This can be described by the following generative model, which is essentially an <em>N</em>-mixture model nested in an occupancy model or a zero-inflated <em>N</em>-mixture model:</p>
<p><span id="eq-zi-nmix"><span class="math display">\[
\begin{aligned}
  z_i &amp;\sim \textrm{Bernoulli} (\psi) \\
  N_i &amp;\sim \textrm{Poisson}(z_i \cdot \lambda) \\
  y_{ij} &amp;\sim \textrm{Binomial}(N_i, p)
\end{aligned}
\tag{10}\]</span></span></p>
<p>The conditional likelihood for the site-level vector of counts <span class="math inline">\(\boldsymbol{y}_i\)</span> is:</p>
<p><span id="eq-zi-nmix-c"><span class="math display">\[
\mathcal{L}_c(\boldsymbol{y}_i \mid \psi, \lambda, p, z_i, N_i) = \textrm{Bernoulli}(z_i \mid \psi) \cdot \textrm{Poisson}(N_i \mid z_i \cdot \lambda) \cdot \prod_{j=1}^{J_i} \textrm{Binomial}(y_{ij} \mid N_i, p)
\tag{11}\]</span></span></p>
<p>The full marginal likelihood is unwieldy to write, but if we define the expression in <a href="#eq-N-m">Equation&nbsp;9</a> as <span class="math inline">\(\theta\)</span>, then the marginal likelihood can be written analogously to our starting occupancy model in <a href="#eq-occ-m2">Equation&nbsp;4</a> as follows:</p>
<p><span id="eq-zi-nmix-m"><span class="math display">\[
\mathcal{L}_m(\boldsymbol{y}_i \mid \psi, \lambda, p) = \begin{cases}
\psi \cdot \theta, &amp;Q_i &gt; 0, \\
1 - \psi + \psi \cdot \theta, &amp;Q_i = 0,
\end{cases}
\tag{12}\]</span></span></p>
<p>where <span class="math inline">\(Q_i\)</span> is the total number of individuals detected across surveys. When marginalising discrete parameters in several hierarchical levels, you should first compute the lower levels (abundance in this case) and then increment the higher levels (occupancy). Let’s simulate some data to start.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># parameters</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>psi <span class="ot">&lt;-</span> <span class="fl">0.8</span></span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="co"># simulate</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>z <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(I, <span class="dv">1</span>, psi)</span>
<span id="cb27-6"><a href="#cb27-6"></a>N <span class="ot">&lt;-</span> <span class="fu">rpois</span>(I, z <span class="sc">*</span> lambda)</span>
<span id="cb27-7"><a href="#cb27-7"></a>y <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, I, J_max)</span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb27-9"><a href="#cb27-9"></a>  y[i, <span class="dv">1</span><span class="sc">:</span>J[i]] <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(J[i], N[i], p)</span>
<span id="cb27-10"><a href="#cb27-10"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Notice that in the <code>generated quantities</code> block, we first simulate posterior draws for <span class="math inline">\(N_i\)</span> for all sites, but then overwrite this value with 0 if the site is estimated to have not been occupied (<span class="math inline">\(z_i = 0\)</span>). This is akin to the forward-backward (Viterbi) algorithm for recovering hidden states in hidden Markov models.</p>
<div class="cell" data-output.var="zi_nmix">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">data</span> {</span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; I, J_max, K;  <span class="co">// number of sites and maximum surveys and population size</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J_max&gt; J;  <span class="co">// number of surveys</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>  <span class="dt">array</span>[I, J_max] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; y;  <span class="co">// detection history</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>}</span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="kw">transformed data</span> {</span>
<span id="cb28-8"><a href="#cb28-8"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> max_y, ks;  <span class="co">// maximum counts and number of population sizes</span></span>
<span id="cb28-9"><a href="#cb28-9"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb28-10"><a href="#cb28-10"></a>    max_y[i] = max(y[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb28-11"><a href="#cb28-11"></a>    ks[i] = K - max_y[i] + <span class="dv">1</span>;</span>
<span id="cb28-12"><a href="#cb28-12"></a>  }</span>
<span id="cb28-13"><a href="#cb28-13"></a>}</span>
<span id="cb28-14"><a href="#cb28-14"></a></span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="kw">parameters</span> {</span>
<span id="cb28-16"><a href="#cb28-16"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; psi_a, p_a;</span>
<span id="cb28-17"><a href="#cb28-17"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; lambda_a;</span>
<span id="cb28-18"><a href="#cb28-18"></a>}</span>
<span id="cb28-19"><a href="#cb28-19"></a></span>
<span id="cb28-20"><a href="#cb28-20"></a><span class="kw">model</span> {</span>
<span id="cb28-21"><a href="#cb28-21"></a>  <span class="co">// priors</span></span>
<span id="cb28-22"><a href="#cb28-22"></a>  <span class="kw">target +=</span> beta_lupdf(psi_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb28-23"><a href="#cb28-23"></a>  <span class="kw">target +=</span> exponential_lupdf(lambda_a | <span class="fl">0.01</span>);</span>
<span id="cb28-24"><a href="#cb28-24"></a>  <span class="kw">target +=</span> beta_lupdf(p_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb28-25"><a href="#cb28-25"></a>  </span>
<span id="cb28-26"><a href="#cb28-26"></a>  <span class="co">// site-level expected counts and site-by-occasion level detection</span></span>
<span id="cb28-27"><a href="#cb28-27"></a>  <span class="dt">vector</span>[I] psi = rep_vector(psi_a, I);</span>
<span id="cb28-28"><a href="#cb28-28"></a>  <span class="dt">vector</span>[I] lambda = rep_vector(lambda_a, I);</span>
<span id="cb28-29"><a href="#cb28-29"></a>  <span class="dt">matrix</span>[I, J_max] p = rep_matrix(p_a, I, J_max);</span>
<span id="cb28-30"><a href="#cb28-30"></a>  </span>
<span id="cb28-31"><a href="#cb28-31"></a>  <span class="co">// log-transform occupancy probabilities</span></span>
<span id="cb28-32"><a href="#cb28-32"></a>  <span class="dt">vector</span>[I] log_psi = log(psi), log1m_psi = log1m(psi);</span>
<span id="cb28-33"><a href="#cb28-33"></a>  </span>
<span id="cb28-34"><a href="#cb28-34"></a>  <span class="co">// likelihood</span></span>
<span id="cb28-35"><a href="#cb28-35"></a>  <span class="dt">real</span> theta;</span>
<span id="cb28-36"><a href="#cb28-36"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb28-37"><a href="#cb28-37"></a>    </span>
<span id="cb28-38"><a href="#cb28-38"></a>    <span class="co">// abundance</span></span>
<span id="cb28-39"><a href="#cb28-39"></a>    <span class="dt">vector</span>[ks[i]] lp;</span>
<span id="cb28-40"><a href="#cb28-40"></a>    <span class="cf">for</span> (k <span class="cf">in</span> max_y[i]:K) {</span>
<span id="cb28-41"><a href="#cb28-41"></a>      lp[k - max_y[i] + <span class="dv">1</span>] = poisson_lpmf(k | lambda[i]) </span>
<span id="cb28-42"><a href="#cb28-42"></a>                             + binomial_lpmf(y[i, <span class="dv">1</span>:J[i]] | k, p[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb28-43"><a href="#cb28-43"></a>    }</span>
<span id="cb28-44"><a href="#cb28-44"></a>    theta = log_sum_exp(lp);</span>
<span id="cb28-45"><a href="#cb28-45"></a>    </span>
<span id="cb28-46"><a href="#cb28-46"></a>    <span class="co">// increment occupancy</span></span>
<span id="cb28-47"><a href="#cb28-47"></a>    <span class="cf">if</span> (max_y[i]) {</span>
<span id="cb28-48"><a href="#cb28-48"></a>      <span class="kw">target +=</span> log_psi[i] + theta;</span>
<span id="cb28-49"><a href="#cb28-49"></a>    } <span class="cf">else</span> {</span>
<span id="cb28-50"><a href="#cb28-50"></a>      <span class="kw">target +=</span> log_sum_exp(log1m_psi[i], log_psi[i] + theta);</span>
<span id="cb28-51"><a href="#cb28-51"></a>    }</span>
<span id="cb28-52"><a href="#cb28-52"></a>  }</span>
<span id="cb28-53"><a href="#cb28-53"></a>}</span>
<span id="cb28-54"><a href="#cb28-54"></a></span>
<span id="cb28-55"><a href="#cb28-55"></a><span class="kw">generated quantities</span> {</span>
<span id="cb28-56"><a href="#cb28-56"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb28-57"><a href="#cb28-57"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> z = ones_int_array(I), N;</span>
<span id="cb28-58"><a href="#cb28-58"></a>  {</span>
<span id="cb28-59"><a href="#cb28-59"></a>    <span class="dt">vector</span>[I] psi = rep_vector(psi_a, I);</span>
<span id="cb28-60"><a href="#cb28-60"></a>    <span class="dt">vector</span>[I] lambda = rep_vector(lambda_a, I);</span>
<span id="cb28-61"><a href="#cb28-61"></a>    <span class="dt">matrix</span>[I, J_max] p = rep_matrix(p_a, I, J_max);</span>
<span id="cb28-62"><a href="#cb28-62"></a>    <span class="dt">vector</span>[I] log_psi = log(psi), log1m_psi = log1m(psi);</span>
<span id="cb28-63"><a href="#cb28-63"></a>    <span class="dt">real</span> theta;</span>
<span id="cb28-64"><a href="#cb28-64"></a>    <span class="dt">row_vector</span>[<span class="dv">2</span>] lp_z;</span>
<span id="cb28-65"><a href="#cb28-65"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb28-66"><a href="#cb28-66"></a>      <span class="dt">vector</span>[ks[i]] lp;</span>
<span id="cb28-67"><a href="#cb28-67"></a>      <span class="cf">for</span> (k <span class="cf">in</span> max_y[i]:K) {</span>
<span id="cb28-68"><a href="#cb28-68"></a>        lp[k - max_y[i] + <span class="dv">1</span>] = poisson_lpmf(k | lambda[i]) </span>
<span id="cb28-69"><a href="#cb28-69"></a>                               + binomial_lpmf(y[i, <span class="dv">1</span>:J[i]] | k, p[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb28-70"><a href="#cb28-70"></a>      }</span>
<span id="cb28-71"><a href="#cb28-71"></a>      theta = log_sum_exp(lp);</span>
<span id="cb28-72"><a href="#cb28-72"></a>      N[i] = categorical_logit_rng(lp - theta) + max_y[i] - <span class="dv">1</span>;</span>
<span id="cb28-73"><a href="#cb28-73"></a>      <span class="cf">if</span> (max_y[i]) {</span>
<span id="cb28-74"><a href="#cb28-74"></a>        log_lik[i] = log_psi[i] + theta;</span>
<span id="cb28-75"><a href="#cb28-75"></a>      } <span class="cf">else</span> {</span>
<span id="cb28-76"><a href="#cb28-76"></a>        lp_z = [ log1m_psi[i], log_psi[i] + theta ];</span>
<span id="cb28-77"><a href="#cb28-77"></a>        log_lik[i] = log_sum_exp(lp_z);</span>
<span id="cb28-78"><a href="#cb28-78"></a>        z[i] = sort_indices_desc(lp_z)[<span class="dv">1</span>] - <span class="dv">1</span>;</span>
<span id="cb28-79"><a href="#cb28-79"></a>        <span class="cf">if</span> (!z[i]) {</span>
<span id="cb28-80"><a href="#cb28-80"></a>          N[i] = <span class="dv">0</span>;</span>
<span id="cb28-81"><a href="#cb28-81"></a>        }</span>
<span id="cb28-82"><a href="#cb28-82"></a>      }</span>
<span id="cb28-83"><a href="#cb28-83"></a>    }</span>
<span id="cb28-84"><a href="#cb28-84"></a>  }</span>
<span id="cb28-85"><a href="#cb28-85"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>After running this model we see estimation went well and latent occupancy states had great recovery. There’s a lot to be said for using counts in the observation models of occupancy models as it provides much more information about <span class="math inline">\(\psi\)</span> than a Binomial likelihood, because collapsing counts to 1s and 0s always discards information. But this might be the subject of a future blog post.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a>zi_nmix_data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J_max =</span> J_max, <span class="at">K =</span> <span class="dv">3</span> <span class="sc">*</span> <span class="fu">max</span>(N), <span class="at">J =</span> J, <span class="at">y =</span> y)</span>
<span id="cb29-2"><a href="#cb29-2"></a>fit_zi_nmix <span class="ot">&lt;-</span> zi_nmix<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="at">data =</span> zi_nmix_data, </span>
<span id="cb29-4"><a href="#cb29-4"></a>  <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> chains, </span>
<span id="cb29-5"><a href="#cb29-5"></a>  <span class="at">iter_warmup =</span> iter_warmup, <span class="at">iter_sampling =</span> iter_sampling</span>
<span id="cb29-6"><a href="#cb29-6"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...

Chain 7 finished in 67.5 seconds.
Chain 8 finished in 70.0 seconds.
Chain 1 finished in 71.0 seconds.
Chain 4 finished in 76.8 seconds.
Chain 5 finished in 84.9 seconds.
Chain 6 finished in 85.9 seconds.
Chain 3 finished in 86.7 seconds.
Chain 2 finished in 94.5 seconds.

All 8 chains finished successfully.
Mean chain execution time: 79.7 seconds.
Total execution time: 94.6 seconds.</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a>fit_zi_nmix<span class="sc">$</span><span class="fu">summary</span>(<span class="fu">c</span>(<span class="st">"psi_a"</span>, <span class="st">"lambda_a"</span>, <span class="st">"p_a"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb31-2"><a href="#cb31-2"></a>  <span class="fu">select</span>(variable, median, <span class="fu">contains</span>(<span class="st">"q"</span>), rhat, <span class="fu">contains</span>(<span class="st">"ess"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb31-3"><a href="#cb31-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(psi, lambda, p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 8
  variable median      q5    q95  rhat ess_bulk ess_tail truth
  &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
1 psi_a     0.825  0.758   0.884  1.00    1521.    1566.   0.8
2 lambda_a 19.6   12.5    41.6    1.01     934.    1002.  20  
3 p_a       0.199  0.0937  0.311  1.01     918.     997.   0.2</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="co"># proportion of sites correctly classified</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="fu">mean</span>(fit_zi_nmix<span class="sc">$</span><span class="fu">summary</span>(<span class="st">"z"</span>)<span class="sc">$</span>median <span class="sc">==</span> z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
</section>
<section id="time-to-event-n-mixture-model" class="level2">
<h2 class="anchored" data-anchor-id="time-to-event-n-mixture-model">Time-to-event <em>N</em>-mixture model</h2>
<p>The final model I’ll consider is a type of continuous time model.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> Time-to-event <em>N</em>-mixture models can be used to estimate abundance under the assumption that detection rates are proportional to abundance <span class="citation" data-cites="strebel2021">(<a href="#ref-strebel2021" role="doc-biblioref">Strebel et al. 2021</a>)</span>. Consider sites <span class="math inline">\(i \in 1:I\)</span> surveyed <span class="math inline">\(j \in 1:J_i\)</span> times for a minimum of length of <span class="math inline">\(\Delta_{ij}\)</span> (e.g., 30 minutes).<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> Surveys are conducted up to <span class="math inline">\(\Delta_{ij}\)</span> or are terminated after the time of first detection, yielding right-censored data <span class="math inline">\(y_{ij} = \Delta_{ij}\)</span> if no detection were made or <span class="math inline">\(y_{ij} &lt; \Delta_{ij}\)</span> if a detection was made. The waiting times are then modeled with some appropriate distribution such as the exponential. We can just replace the observation model in the zero-inflated <em>N</em>-mixture model in <a href="#eq-zi-nmix">Equation&nbsp;10</a> by modeling the waiting times as a function of the product of the per-individual detection rate <span class="math inline">\(\mu\)</span> and site-level abundance <span class="math inline">\(N_i\)</span>, yielding the following data-generating process:</p>
<p><span id="eq-tte"><span class="math display">\[
\begin{aligned}
  z_i &amp;\sim \textrm{Bernoulli} (\psi) \\
  N_i &amp;\sim \textrm{Poisson}(z_i \cdot \lambda) \\
  y_{ij} &amp;\sim \min(\textrm{Exponential}(N_i \cdot \mu), \Delta_{ij})
\end{aligned}
\tag{13}\]</span></span></p>
<p>Just out of curiosity, I’m going to use the same parameters as for first zero-inflated <em>N</em>-mixture model above, leveraging the fact that <span class="math inline">\(\mu = -\log(1 - p)\)</span>.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> Since I’m trying to compare these models, I’ll assume that <span class="math inline">\(\Delta = 1\)</span> for all surveys, but this doesn’t have to be case for these models.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># convert detection probability to rate</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>mu <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fu">log</span>(<span class="dv">1</span> <span class="sc">-</span> p)</span>
<span id="cb35-3"><a href="#cb35-3"></a></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="co"># simulate</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>Delta_max <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>y <span class="ot">&lt;-</span> Delta <span class="ot">&lt;-</span> <span class="fu">matrix</span>(Delta_max, I, J_max)</span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb35-8"><a href="#cb35-8"></a>  <span class="cf">if</span> (N[i]) {</span>
<span id="cb35-9"><a href="#cb35-9"></a>    y[i, <span class="dv">1</span><span class="sc">:</span>J[i]] <span class="ot">&lt;-</span> <span class="fu">pmin</span>(<span class="fu">rexp</span>(J[i], N[i] <span class="sc">*</span> mu), Delta[i, <span class="dv">1</span><span class="sc">:</span>J[i]])</span>
<span id="cb35-10"><a href="#cb35-10"></a>  }</span>
<span id="cb35-11"><a href="#cb35-11"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The Stan program uses the log density function <code>exponential_lpdf</code> when detections were made (<code>y[i, j] &lt; Delta[i, j]</code>), and the complement of the cumulative density function <code>exponential_lccdf</code> if no detections were made. The latter gives the log probability of not making any detections during the survey of length <span class="math inline">\(\Delta_{ij}\)</span>. Therefore, we can’t vectorise over the surveys because the density function depends on whether or not there was a detection in each survey.</p>
<div class="cell" data-output.var="tte">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">data</span> {</span>
<span id="cb36-2"><a href="#cb36-2"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; I, J_max, K, Delta_max;  <span class="co">// number of sites and maximum surveys, population size, and survey length</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J_max&gt; J;  <span class="co">// number of surveys</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>  <span class="dt">matrix</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt;[I, J_max] Delta, y;  <span class="co">// survey lengths and detection history</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>}</span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="kw">transformed data</span> {</span>
<span id="cb36-8"><a href="#cb36-8"></a>  <span class="dt">array</span>[I, J_max] <span class="dt">int</span> Q;  <span class="co">// indicator for detection</span></span>
<span id="cb36-9"><a href="#cb36-9"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> Q_sum = zeros_int_array(I);  <span class="co">// number of detections</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb36-11"><a href="#cb36-11"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span>:J[i]) {</span>
<span id="cb36-12"><a href="#cb36-12"></a>      Q[i, j] = y[i, j] &lt; Delta[i, j];</span>
<span id="cb36-13"><a href="#cb36-13"></a>    }</span>
<span id="cb36-14"><a href="#cb36-14"></a>    Q_sum[i] = sum(Q[i, <span class="dv">1</span>:J[i]]);</span>
<span id="cb36-15"><a href="#cb36-15"></a>  }</span>
<span id="cb36-16"><a href="#cb36-16"></a>}</span>
<span id="cb36-17"><a href="#cb36-17"></a></span>
<span id="cb36-18"><a href="#cb36-18"></a><span class="kw">parameters</span> {</span>
<span id="cb36-19"><a href="#cb36-19"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; psi_a;</span>
<span id="cb36-20"><a href="#cb36-20"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; lambda_a, mu_a;</span>
<span id="cb36-21"><a href="#cb36-21"></a>}</span>
<span id="cb36-22"><a href="#cb36-22"></a></span>
<span id="cb36-23"><a href="#cb36-23"></a><span class="kw">model</span> {</span>
<span id="cb36-24"><a href="#cb36-24"></a>  <span class="co">// priors</span></span>
<span id="cb36-25"><a href="#cb36-25"></a>  <span class="kw">target +=</span> beta_lupdf(psi_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb36-26"><a href="#cb36-26"></a>  <span class="kw">target +=</span> exponential_lupdf(lambda_a | <span class="fl">0.01</span>);</span>
<span id="cb36-27"><a href="#cb36-27"></a>  <span class="kw">target +=</span> exponential_lupdf(mu_a | <span class="fl">0.1</span>);</span>
<span id="cb36-28"><a href="#cb36-28"></a>  </span>
<span id="cb36-29"><a href="#cb36-29"></a>  <span class="co">// site-level expected counts and site-by-occasion level detection</span></span>
<span id="cb36-30"><a href="#cb36-30"></a>  <span class="dt">vector</span>[I] psi = rep_vector(psi_a, I);</span>
<span id="cb36-31"><a href="#cb36-31"></a>  <span class="dt">vector</span>[I] lambda = rep_vector(lambda_a, I);</span>
<span id="cb36-32"><a href="#cb36-32"></a>  <span class="dt">matrix</span>[I, J_max] mu = rep_matrix(mu_a, I, J_max);</span>
<span id="cb36-33"><a href="#cb36-33"></a>  </span>
<span id="cb36-34"><a href="#cb36-34"></a>  <span class="co">// log-transform occupancy probabilities</span></span>
<span id="cb36-35"><a href="#cb36-35"></a>  <span class="dt">vector</span>[I] log_psi = log(psi), log1m_psi = log1m(psi);</span>
<span id="cb36-36"><a href="#cb36-36"></a>  </span>
<span id="cb36-37"><a href="#cb36-37"></a>  <span class="co">// likelihood</span></span>
<span id="cb36-38"><a href="#cb36-38"></a>  <span class="dt">vector</span>[K] lp;</span>
<span id="cb36-39"><a href="#cb36-39"></a>  <span class="dt">real</span> theta;</span>
<span id="cb36-40"><a href="#cb36-40"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb36-41"><a href="#cb36-41"></a>    </span>
<span id="cb36-42"><a href="#cb36-42"></a>    <span class="co">// abundance</span></span>
<span id="cb36-43"><a href="#cb36-43"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb36-44"><a href="#cb36-44"></a>      lp[k] = poisson_lpmf(k | lambda[i]);</span>
<span id="cb36-45"><a href="#cb36-45"></a>      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span>:J[i]) {</span>
<span id="cb36-46"><a href="#cb36-46"></a>        <span class="cf">if</span> (Q[i, j]) {</span>
<span id="cb36-47"><a href="#cb36-47"></a>          lp[k] += exponential_lpdf(y[i, j] | k * mu[i, j]);</span>
<span id="cb36-48"><a href="#cb36-48"></a>        } <span class="cf">else</span> {</span>
<span id="cb36-49"><a href="#cb36-49"></a>          lp[k] += exponential_lccdf(Delta[i, j] | k * mu[i, j]);</span>
<span id="cb36-50"><a href="#cb36-50"></a>        }</span>
<span id="cb36-51"><a href="#cb36-51"></a>      }</span>
<span id="cb36-52"><a href="#cb36-52"></a>    }</span>
<span id="cb36-53"><a href="#cb36-53"></a>    theta = log_sum_exp(lp);</span>
<span id="cb36-54"><a href="#cb36-54"></a>    </span>
<span id="cb36-55"><a href="#cb36-55"></a>    <span class="co">// increment occupancy</span></span>
<span id="cb36-56"><a href="#cb36-56"></a>    <span class="cf">if</span> (Q_sum[i]) {</span>
<span id="cb36-57"><a href="#cb36-57"></a>      <span class="kw">target +=</span> log_psi[i] + theta;</span>
<span id="cb36-58"><a href="#cb36-58"></a>    } <span class="cf">else</span> {</span>
<span id="cb36-59"><a href="#cb36-59"></a>      <span class="kw">target +=</span> log_sum_exp(log1m_psi[i], log_psi[i] + theta);</span>
<span id="cb36-60"><a href="#cb36-60"></a>    }</span>
<span id="cb36-61"><a href="#cb36-61"></a>  }</span>
<span id="cb36-62"><a href="#cb36-62"></a>}</span>
<span id="cb36-63"><a href="#cb36-63"></a></span>
<span id="cb36-64"><a href="#cb36-64"></a><span class="kw">generated quantities</span> {</span>
<span id="cb36-65"><a href="#cb36-65"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb36-66"><a href="#cb36-66"></a>  <span class="dt">array</span>[I] <span class="dt">int</span> z = ones_int_array(I), N;</span>
<span id="cb36-67"><a href="#cb36-67"></a>  {</span>
<span id="cb36-68"><a href="#cb36-68"></a>    <span class="dt">vector</span>[I] psi = rep_vector(psi_a, I);</span>
<span id="cb36-69"><a href="#cb36-69"></a>    <span class="dt">vector</span>[I] lambda = rep_vector(lambda_a, I);</span>
<span id="cb36-70"><a href="#cb36-70"></a>    <span class="dt">matrix</span>[I, J_max] mu = rep_matrix(mu_a, I, J_max);</span>
<span id="cb36-71"><a href="#cb36-71"></a>    <span class="dt">vector</span>[I] log_psi = log(psi), log1m_psi = log1m(psi);</span>
<span id="cb36-72"><a href="#cb36-72"></a>    <span class="dt">real</span> theta;</span>
<span id="cb36-73"><a href="#cb36-73"></a>    <span class="dt">vector</span>[K] lp;</span>
<span id="cb36-74"><a href="#cb36-74"></a>    <span class="dt">row_vector</span>[<span class="dv">2</span>] lp_z;</span>
<span id="cb36-75"><a href="#cb36-75"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb36-76"><a href="#cb36-76"></a>      <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb36-77"><a href="#cb36-77"></a>        lp[k] = poisson_lpmf(k | lambda[i]);</span>
<span id="cb36-78"><a href="#cb36-78"></a>        <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span>:J[i]) {</span>
<span id="cb36-79"><a href="#cb36-79"></a>          <span class="cf">if</span> (Q[i, j]) {</span>
<span id="cb36-80"><a href="#cb36-80"></a>            lp[k] += exponential_lpdf(y[i, j] | k * mu[i, j]);</span>
<span id="cb36-81"><a href="#cb36-81"></a>          } <span class="cf">else</span> {</span>
<span id="cb36-82"><a href="#cb36-82"></a>            lp[k] += exponential_lccdf(Delta[i, j] | k * mu[i, j]);</span>
<span id="cb36-83"><a href="#cb36-83"></a>          }</span>
<span id="cb36-84"><a href="#cb36-84"></a>        }</span>
<span id="cb36-85"><a href="#cb36-85"></a>      }</span>
<span id="cb36-86"><a href="#cb36-86"></a>      theta = log_sum_exp(lp);</span>
<span id="cb36-87"><a href="#cb36-87"></a>      N[i] = categorical_logit_rng(lp - theta);</span>
<span id="cb36-88"><a href="#cb36-88"></a>      <span class="cf">if</span> (Q_sum[i]) {</span>
<span id="cb36-89"><a href="#cb36-89"></a>        log_lik[i] = log_psi[i] + theta;</span>
<span id="cb36-90"><a href="#cb36-90"></a>      } <span class="cf">else</span> {</span>
<span id="cb36-91"><a href="#cb36-91"></a>        lp_z = [ log1m_psi[i], log_psi[i] + theta ];</span>
<span id="cb36-92"><a href="#cb36-92"></a>        log_lik[i] = log_sum_exp(lp_z);</span>
<span id="cb36-93"><a href="#cb36-93"></a>        z[i] = sort_indices_desc(lp_z)[<span class="dv">1</span>] - <span class="dv">1</span>;</span>
<span id="cb36-94"><a href="#cb36-94"></a>        <span class="cf">if</span> (!z[i]) {</span>
<span id="cb36-95"><a href="#cb36-95"></a>          N[i] = <span class="dv">0</span>;</span>
<span id="cb36-96"><a href="#cb36-96"></a>        }</span>
<span id="cb36-97"><a href="#cb36-97"></a>      }</span>
<span id="cb36-98"><a href="#cb36-98"></a>    }</span>
<span id="cb36-99"><a href="#cb36-99"></a>  }</span>
<span id="cb36-100"><a href="#cb36-100"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s fit the time-to-event model, check the posteriors, and plot a subset of the abundance estimates alongside those of the first zero-inflated <em>N</em>-mixture model.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a>fit_tte <span class="ot">&lt;-</span> tte<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb37-2"><a href="#cb37-2"></a>  <span class="at">data =</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J_max =</span> J_max, <span class="at">K =</span> <span class="dv">3</span> <span class="sc">*</span> <span class="fu">max</span>(N), <span class="at">Delta_max =</span> Delta_max, <span class="at">J =</span> J, <span class="at">Delta =</span> Delta, <span class="at">y =</span> y), </span>
<span id="cb37-3"><a href="#cb37-3"></a>  <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> chains, </span>
<span id="cb37-4"><a href="#cb37-4"></a>  <span class="at">iter_warmup =</span> iter_warmup, <span class="at">iter_sampling =</span> iter_sampling</span>
<span id="cb37-5"><a href="#cb37-5"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Chain 2 finished in 27.5 seconds.
Chain 7 finished in 30.4 seconds.
Chain 3 finished in 31.8 seconds.
Chain 5 finished in 33.4 seconds.
Chain 8 finished in 34.3 seconds.
Chain 4 finished in 34.9 seconds.
Chain 6 finished in 35.1 seconds.
Chain 1 finished in 36.0 seconds.

All 8 chains finished successfully.
Mean chain execution time: 32.9 seconds.
Total execution time: 36.1 seconds.</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a>fit_tte<span class="sc">$</span><span class="fu">summary</span>(<span class="fu">c</span>(<span class="st">"psi_a"</span>, <span class="st">"lambda_a"</span>, <span class="st">"mu_a"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb40-2"><a href="#cb40-2"></a>  <span class="fu">select</span>(variable, median, <span class="fu">contains</span>(<span class="st">"q"</span>), rhat, <span class="fu">contains</span>(<span class="st">"ess"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb40-3"><a href="#cb40-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(psi, lambda, mu))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 8
  variable median    q5    q95  rhat ess_bulk ess_tail  truth
  &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;
1 psi_a     0.827 0.759  0.883  1.01    1429.    1181.  0.8  
2 lambda_a 11.1   5.29  38.6    1.01     902.     857. 20    
3 mu_a      0.393 0.106  0.884  1.01     906.     848.  0.223</code></pre>
</div>
</div>
<div class="cell" data-fig.asp="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a>out <span class="ot">&lt;-</span> <span class="fu">map</span>(<span class="fu">list</span>(fit_zi_nmix, fit_tte), </span>
<span id="cb42-2"><a href="#cb42-2"></a>    <span class="sc">~</span>(<span class="fu">spread_rvars</span>(.x, z[i], N[i]))) <span class="sc">|&gt;</span> </span>
<span id="cb42-3"><a href="#cb42-3"></a>  <span class="fu">list_rbind</span>(<span class="at">names_to =</span> <span class="st">"model"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb42-4"><a href="#cb42-4"></a>  <span class="fu">mutate</span>(<span class="at">model =</span> <span class="fu">factor</span>(model, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"Counts"</span>, <span class="st">"Time-to-event"</span>))) <span class="sc">|&gt;</span> </span>
<span id="cb42-5"><a href="#cb42-5"></a>  <span class="fu">left_join</span>(<span class="fu">tibble</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>I, <span class="at">truth =</span> N), <span class="at">by =</span> <span class="st">"i"</span>)</span>
<span id="cb42-6"><a href="#cb42-6"></a></span>
<span id="cb42-7"><a href="#cb42-7"></a>out <span class="sc">|&gt;</span> </span>
<span id="cb42-8"><a href="#cb42-8"></a>  <span class="fu">filter</span>(i <span class="sc">&lt;=</span> <span class="dv">25</span>) <span class="sc">|&gt;</span> </span>
<span id="cb42-9"><a href="#cb42-9"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">xdist =</span> N, <span class="at">y =</span> <span class="fu">factor</span>(i) <span class="sc">|&gt;</span> <span class="fu">fct_rev</span>())) <span class="sc">+</span> </span>
<span id="cb42-10"><a href="#cb42-10"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> model) <span class="sc">+</span> </span>
<span id="cb42-11"><a href="#cb42-11"></a>  <span class="fu">stat_pointinterval</span>(<span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span> </span>
<span id="cb42-12"><a href="#cb42-12"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x =</span> truth), </span>
<span id="cb42-13"><a href="#cb42-13"></a>             <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="sc">-</span><span class="fl">0.3</span>), </span>
<span id="cb42-14"><a href="#cb42-14"></a>             <span class="at">size =</span> <span class="dv">2</span>, </span>
<span id="cb42-15"><a href="#cb42-15"></a>             <span class="at">colour =</span> <span class="st">"red4"</span>, </span>
<span id="cb42-16"><a href="#cb42-16"></a>             <span class="at">shape =</span> <span class="st">"cross"</span>) <span class="sc">+</span> </span>
<span id="cb42-17"><a href="#cb42-17"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="fu">expression</span>(N), </span>
<span id="cb42-18"><a href="#cb42-18"></a>       <span class="at">y =</span> <span class="st">"Occupied Site"</span>, </span>
<span id="cb42-19"><a href="#cb42-19"></a>       <span class="at">colour =</span> <span class="st">"Model"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="marginalisation_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The estimates for the count model look better and seemed to perform better according to RMSE of the population sizes, which makes sense because the count model can provide more information (number of individuals detected) compared to the time-to-event model (waiting time to the first individual detected). Since the <span class="math inline">\(\textrm{Binomial}(N_i, p)\)</span> distribution converges to <span class="math inline">\(\textrm{Poisson}(N_i \cdot p)\)</span> for sufficiently large <span class="math inline">\(N\)</span> and sufficiently small <span class="math inline">\(p\)</span><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>, and because <span class="math inline">\(p \approx \mu\)</span> for small values of <span class="math inline">\(p\)</span>, researchers gain statistical power by not terminating the search after first detection but instead counting the number of individuals during the interval <span class="math inline">\(\Delta_{ij}\)</span>. But of course, one of the big draws of the time-to-event model is less time in the field; you win some, you lose some.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a>out <span class="sc">|&gt;</span> </span>
<span id="cb43-2"><a href="#cb43-2"></a>  <span class="fu">summarise</span>(<span class="at">RMSE =</span> <span class="fu">sqrt</span>(<span class="fu">rvar_mean</span>((truth <span class="sc">-</span> N)<span class="sc">^</span><span class="dv">2</span>)), </span>
<span id="cb43-3"><a href="#cb43-3"></a>            <span class="at">.by =</span> model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 2
  model               RMSE
  &lt;fct&gt;         &lt;rvar[1d]&gt;
1 Counts           8 ± 5.9
2 Time-to-event   11 ± 5.6</code></pre>
</div>
</div>
<p>At least our occupancy states are still estimated well.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="fu">mean</span>(fit_tte<span class="sc">$</span><span class="fu">summary</span>(<span class="st">"z"</span>)<span class="sc">$</span>median <span class="sc">==</span> z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Thanks for reading!</p>
</section>
</section>
<section id="references" class="level1">




</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-line-spacing="2" role="list">
<div id="ref-burkner2024" class="csl-entry" role="listitem">
Bürkner, P.-C., J. Gabry, M. Kay, and A. Vehtari. 2024. <span class="nocase">posterior</span>: <span>Tools</span> for working with posterior distributions.
</div>
<div id="ref-carpenter2017" class="csl-entry" role="listitem">
Carpenter, B., A. Gelman, M. D. Hoffman, D. Lee, B. Goodrich, M. Betancourt, M. A. Brubaker, J. Guo, P. Li, and A. Riddell. 2017. <a href="https://doi.org/10.18637/jss.v076.i01">Stan: <span>A Probabilistic Programming Language</span></a>. Journal of Statistical Software 76:1.
</div>
<div id="ref-ergon2018" class="csl-entry" role="listitem">
Ergon, T., Ø. Borgan, C. R. Nater, and Y. Vindenes. 2018. <a href="https://doi.org/10.1111/2041-210X.13059">The utility of mortality hazard rates in population analyses</a>. Methods in Ecology and Evolution 9:2046–2056.
</div>
<div id="ref-gabry2024" class="csl-entry" role="listitem">
Gabry, J., R. Češnovar, A. Johnson, and S. Bronder. 2024. <span class="nocase">cmdstanr</span>: <span>R Interface</span> to ’<span>CmdStan</span>’.
</div>
<div id="ref-kay2024" class="csl-entry" role="listitem">
Kay, M. 2024. <a href="https://doi.org/10.5281/zenodo.1308151"><span class="nocase">tidybayes</span>: <span>Tidy</span> data and geoms for <span>Bayesian</span> models</a>.
</div>
<div id="ref-mackenzie2002" class="csl-entry" role="listitem">
MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege, J. Andrew Royle, and C. A. Langtimm. 2002. <a href="https://doi.org/10.1890/0012-9658(2002)083[2248:ESORWD]2.0.CO;2">Estimating site occupancy rates when detection probabilities are less than one</a>. Ecology 83:2248–2255.
</div>
<div id="ref-royle2004" class="csl-entry" role="listitem">
Royle, J. A. 2004. <a href="https://doi.org/10.1111/j.0006-341X.2004.00142.x"><span><em>N</em></span>-mixture models for estimating population size from spatially replicated counts</a>. Biometrics 60:108–115.
</div>
<div id="ref-strebel2021" class="csl-entry" role="listitem">
Strebel, N., C. J. Fiss, K. F. Kellner, J. L. Larkin, M. Kéry, and J. Cohen. 2021. <a href="https://doi.org/10.1111/2041-210X.13570">Estimating abundance based on time-to-detection data</a>. Methods in Ecology and Evolution 12:909–920.
</div>
<div id="ref-vehtari2024" class="csl-entry" role="listitem">
Vehtari, A., J. Gabry, M. Magnusson, Y. Yao, P.-C. Bürkner, T. Paananen, and A. Gelman. 2024. <span class="nocase">loo</span>: <span>Efficient</span> leave-one-out cross-validation and <span>WAIC</span> for <span>Bayesian</span> models.
</div>
<div id="ref-wickham2019" class="csl-entry" role="listitem">
Wickham, H., M. Averick, J. Bryan, W. Chang, L. D. McGowan, R. François, G. Grolemund, A. Hayes, L. Henry, J. Hester, M. Kuhn, T. L. Pedersen, E. Miller, S. M. Bache, K. Müller, J. Ooms, D. Robinson, D. P. Seidel, V. Spinu, K. Takahashi, D. Vaughan, C. Wilke, K. Woo, and H. Yutani. 2019. <a href="https://doi.org/10.21105/joss.01686">Welcome to the <span class="nocase">tidyverse</span></a>. Journal of Open Source Software 4:1686.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The number of surveys can vary by site, which is the norm rather than the exception in ecological data.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>We do know that sites with detections are occupied.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Both <span class="math inline">\(\psi\)</span> and <span class="math inline">\(p\)</span> can be modeled as functions of covariates or random effects at the site-level (occupancy) or the site-by-survey level (detection).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>We could still formulate this with varying number of surveys, except that now the cell probabilities have to be expanded to not only account for the <span class="math inline">\(J + 1\)</span> possible outcomes but also the variation in <span class="math inline">\(J_i\)</span> itself.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Normalising probabilities means to divide by the sum of total probabilities, which is achieved by subtracting the <code>log_sum_exp</code> of the log probabilities.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>This is referred to as <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">inverse transform sampling</a>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>The traditional <em>N</em>-mixture model can become a continuous time model by incorporating the survey lengths into the observation model.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>The survey times can vary by site and occasion.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Probabilities can be converted to rates like this more generally, such as survival probabilities as a function of instantaneous mortality hazard rates <span class="math inline">\(S = 1 - \exp(-h)\)</span> <span class="citation" data-cites="ergon2018">(<a href="#ref-ergon2018" role="doc-biblioref">Ergon et al. 2018</a>)</span>.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>See <a href="https://en.wikipedia.org/wiki/Binomial_distribution#Poisson_approximation">Wikipedia</a> for some rules of thumb.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp("https:\/\/quantecol\.com\.au");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // default icon
          link.classList.add("external");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">Quantecol | 53 Bentinck Street, Ballina NSW, Australia | ABN: 90 710 874 314</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>