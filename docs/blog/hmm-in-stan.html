<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dr.&nbsp;Matthijs Hollanders">
<meta name="dcterms.date" content="2024-05-05">

<title>Quantecol - Ecological Modeling in Stan – Quantecol</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../img/Icon-Quantecol-RGB-FA-1-500.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-2741878938bdabb56c3a6f58ebb39665.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Quantecol - Ecological Modeling in Stan">
<meta property="og:description" content="">
<meta property="og:image" content="https://quantecol.com.au/img/tiger.jpg">
<meta property="og:site_name" content="Quantecol">
<meta name="twitter:title" content="Quantecol - Ecological Modeling in Stan">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://quantecol.com.au/img/tiger.jpg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../img/Logo-Quantecol-RGB-FA-2-1000.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../services.html"> 
<span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../about/vision.html">
 <span class="dropdown-text">Our Vision</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../about/people/matthijs.html">
 <span class="dropdown-text">People</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../about/contact.html">
 <span class="dropdown-text">Contact Us</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/realQuantecol"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#marginalisation" id="toc-marginalisation" class="nav-link" data-scroll-target="#marginalisation">Marginalisation</a>
  <ul class="collapse">
  <li><a href="#forward-algorithm" id="toc-forward-algorithm" class="nav-link" data-scroll-target="#forward-algorithm">Forward algorithm</a></li>
  <li><a href="#posterior-distributions-for-the-discrete-parameters" id="toc-posterior-distributions-for-the-discrete-parameters" class="nav-link" data-scroll-target="#posterior-distributions-for-the-discrete-parameters">Posterior distributions for the discrete parameters</a></li>
  </ul></li>
  <li><a href="#example-1-basic-mark-recapture-as-a-hmm" id="toc-example-1-basic-mark-recapture-as-a-hmm" class="nav-link" data-scroll-target="#example-1-basic-mark-recapture-as-a-hmm">Example 1: Basic mark-recapture as a HMM</a>
  <ul class="collapse">
  <li><a href="#stan-programs" id="toc-stan-programs" class="nav-link" data-scroll-target="#stan-programs">Stan programs</a></li>
  <li><a href="#why-we-like-hmc" id="toc-why-we-like-hmc" class="nav-link" data-scroll-target="#why-we-like-hmc">Why we like HMC</a></li>
  </ul></li>
  <li><a href="#example-2-dynamic-multistate-occupancy-model" id="toc-example-2-dynamic-multistate-occupancy-model" class="nav-link" data-scroll-target="#example-2-dynamic-multistate-occupancy-model">Example 2: Dynamic multistate occupancy model</a>
  <ul class="collapse">
  <li><a href="#simulating-continuous-time" id="toc-simulating-continuous-time" class="nav-link" data-scroll-target="#simulating-continuous-time">Simulating continuous time</a></li>
  <li><a href="#observation-process" id="toc-observation-process" class="nav-link" data-scroll-target="#observation-process">Observation process</a></li>
  <li><a href="#stan-program" id="toc-stan-program" class="nav-link" data-scroll-target="#stan-program">Stan program</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  </ul></li>
  <li><a href="#example-3-disease-structured-mark-recapture-with-state-misclassification" id="toc-example-3-disease-structured-mark-recapture-with-state-misclassification" class="nav-link" data-scroll-target="#example-3-disease-structured-mark-recapture-with-state-misclassification">Example 3: Disease-structured mark-recapture with state misclassification</a>
  <ul class="collapse">
  <li><a href="#nothing-is-certain" id="toc-nothing-is-certain" class="nav-link" data-scroll-target="#nothing-is-certain">Nothing is certain</a></li>
  <li><a href="#double-decking-the-hmm" id="toc-double-decking-the-hmm" class="nav-link" data-scroll-target="#double-decking-the-hmm">Double-decking the HMM</a></li>
  <li><a href="#always-try-to-use-all-of-the-data" id="toc-always-try-to-use-all-of-the-data" class="nav-link" data-scroll-target="#always-try-to-use-all-of-the-data">Always try to use all of the data</a></li>
  <li><a href="#simulation" id="toc-simulation" class="nav-link" data-scroll-target="#simulation">Simulation</a></li>
  <li><a href="#stan-implementation" id="toc-stan-implementation" class="nav-link" data-scroll-target="#stan-implementation">Stan implementation</a></li>
  <li><a href="#results-1" id="toc-results-1" class="nav-link" data-scroll-target="#results-1">Results</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A unified approach to ecological modeling in Stan</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p><a href="../about/people/matthijs.html">Dr.&nbsp;Matthijs Hollanders</a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 5, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This post was updated
</div>
</div>
<div class="callout-body-container callout-body">
<p>I updated the post to replace the Viterbi algorithm (which gives the most likely sequence of latent discrete states based on the highest probabilities) with the backward sampling algorithm (which yields the most likely sequence of states by sampling them according to their probabilities) to retrieve the posterior distributions of the marginalised variables. Additionally, I made some models more efficient and updated some text and plotting.</p>
</div>
</div>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The development of Bayesian statistical software had considerable influence on statistical ecology because many ecological models are complex and require custom likelihoods that were not necessarily available in off-the-shelf software such as R or Program Mark <span class="citation" data-cites="cooch2008a kery2015 kery2020a">(<a href="#ref-cooch2008a" role="doc-biblioref">Cooch and White 2008</a>, <a href="#ref-kery2015" role="doc-biblioref">Kéry and Royle 2015</a>, <a href="#ref-kery2020a" role="doc-biblioref">Kéry and Royle 2020</a>)</span>. One of the reasons why ecological models are so complex is because the data are often messy. For instance, in something like a randomised control trial, careful design means you can make stronger assumptions such as that measurements are obtained without error. However, ecological data are noisy and we frequently require complicated observation models that account for imperfect detection of species or individuals. As a result, a large class of ecological models can be formulated as hidden Markov models (HMMs), where time-series data are modeled with a (partially or completely) unobserved ecological model and an observation model conditioned on it. Examples of ecological HMMs include mark-recapture and occupancy models, including their more complex multistate variants.</p>
<p>HMMs are straightforward to model with traditional Markov chain Monte Carlo (MCMC) methods because the latent ecological states can be sampled like parameters. Formulating these models became accessible to ecologists because of the simplicity afforded by statistical software like BUGS, <a href="https://mcmc-jags.sourceforge.io/">JAGS</a>, and <a href="https://r-nimble.org/">NIMBLE</a> <span class="citation" data-cites="devalpine2017">(<a href="#ref-devalpine2017" role="doc-biblioref">de Valpine et al. 2017</a>)</span>. Consider the simple mark-recapture model where individuals <span class="math inline">\(i \in 1 : I\)</span> first captured at time <span class="math inline">\(j = f_i\)</span> survive between times <span class="math inline">\(j \in f_i: J\)</span> with survival probability <span class="math inline">\(\phi\)</span> and are recaptured on each occasion with detection probability <span class="math inline">\(p\)</span>. The <a href="https://en.wikipedia.org/wiki/State-space_representation">state-space</a> formulation of this model from <span class="math inline">\(j \in (f_i + 1):J\)</span> with vague priors for <span class="math inline">\(\phi\)</span> and <span class="math inline">\(p\)</span> is as follows:</p>
<p><span id="eq-cjs"><span class="math display">\[
\begin{aligned}
  z_{i,j} &amp;\sim \textrm{Bernoulli} \left( z_{i,j-1} \cdot \phi \right) \\
  y_{i,j} &amp;\sim \textrm{Bernoulli} \left( z_{i,j} \cdot p \right) \\
  \phi, p &amp;\sim \textrm{Beta} \left( 1, 1 \right)
\end{aligned}
\tag{1}\]</span></span></p>
<p>where <span class="math inline">\(z_{i,j}\)</span> are the partially observed ecological states (where <span class="math inline">\(z=1\)</span> is an alive individual and <span class="math inline">\(z=0\)</span> is a dead individual) and <span class="math inline">\(y_{i,j}\)</span> are the observed data (where <span class="math inline">\(y=1\)</span> is an observed individual and <span class="math inline">\(y=0\)</span> is an unobserved individual). Using NIMBLE 1.1.0 in R 4.3.2 <span class="citation" data-cites="rcoreteam2023">(<a href="#ref-rcoreteam2023" role="doc-biblioref">R Core Team 2023</a>)</span>, coding this model is straightforward and follows the algebra above closely.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">library</span>(nimble)</span>
<span id="cb1-2"><a href="#cb1-2"></a>cmr_code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>(</span>
<span id="cb1-3"><a href="#cb1-3"></a>  {</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="co"># priors</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    phi <span class="sc">~</span> <span class="fu">dbeta</span>(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>    p <span class="sc">~</span> <span class="fu">dbeta</span>(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="co"># likelihood</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb1-9"><a href="#cb1-9"></a>      <span class="co"># initial state is known</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>      z[i, f[i]] <span class="ot">&lt;-</span> y[i, f[i]]</span>
<span id="cb1-11"><a href="#cb1-11"></a>      <span class="co"># subsequent surveys</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (f[i] <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span>J) {</span>
<span id="cb1-13"><a href="#cb1-13"></a>        z[i, j] <span class="sc">~</span> <span class="fu">dbern</span>(z[i, j <span class="sc">-</span> <span class="dv">1</span>] <span class="sc">*</span> phi)</span>
<span id="cb1-14"><a href="#cb1-14"></a>        y[i, j] <span class="sc">~</span> <span class="fu">dbern</span>(z[i, j] <span class="sc">*</span> p)</span>
<span id="cb1-15"><a href="#cb1-15"></a>      }</span>
<span id="cb1-16"><a href="#cb1-16"></a>    }</span>
<span id="cb1-17"><a href="#cb1-17"></a>  }</span>
<span id="cb1-18"><a href="#cb1-18"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>After simulating some data, creating a NIMBLE model from the code, and configuring the MCMC, we can see that each unknown <code>z[i, j]</code> gets its own binary MCMC sampler.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># metadata and parameters</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>I <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>J <span class="ot">&lt;-</span> <span class="dv">8</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>phi <span class="ot">&lt;-</span> <span class="fl">0.6</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>p <span class="ot">&lt;-</span> <span class="fl">0.7</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co"># containers</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>z <span class="ot">&lt;-</span> y <span class="ot">&lt;-</span> z_known <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, I, J)</span>
<span id="cb2-9"><a href="#cb2-9"></a>f <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>(J <span class="sc">-</span> <span class="dv">1</span>), I, <span class="at">replace =</span> T) <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb2-10"><a href="#cb2-10"></a>l <span class="ot">&lt;-</span> <span class="fu">numeric</span>(I)</span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co"># simulation</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb2-14"><a href="#cb2-14"></a>  z[i, f[i]] <span class="ot">&lt;-</span> y[i, f[i]] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span class="cf">for</span> (j <span class="cf">in</span> (f[i] <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span>J) {</span>
<span id="cb2-16"><a href="#cb2-16"></a>    z[i, j] <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(<span class="dv">1</span>, <span class="dv">1</span>, z[i, j <span class="sc">-</span> <span class="dv">1</span>] <span class="sc">*</span> phi)</span>
<span id="cb2-17"><a href="#cb2-17"></a>    y[i, j] <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(<span class="dv">1</span>, <span class="dv">1</span>, z[i, j] <span class="sc">*</span> p)</span>
<span id="cb2-18"><a href="#cb2-18"></a>  } <span class="co"># t</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>  l[i] <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">which</span>(y[i, ] <span class="sc">==</span> <span class="dv">1</span>))</span>
<span id="cb2-20"><a href="#cb2-20"></a>  z_known[i, f[i]<span class="sc">:</span>l[i]] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>} <span class="co"># i</span></span>
<span id="cb2-22"><a href="#cb2-22"></a></span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="co"># create NIMBLE model object</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>Rmodel <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(cmr_code, </span>
<span id="cb2-25"><a href="#cb2-25"></a>                      <span class="at">constants =</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J =</span> J, <span class="at">f =</span> f),</span>
<span id="cb2-26"><a href="#cb2-26"></a>                      <span class="at">data =</span> <span class="fu">list</span>(<span class="at">y =</span> y, <span class="at">z =</span> z_known))</span>
<span id="cb2-27"><a href="#cb2-27"></a></span>
<span id="cb2-28"><a href="#cb2-28"></a><span class="co"># configure MCMC</span></span>
<span id="cb2-29"><a href="#cb2-29"></a>conf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>===== Monitors =====
thin = 1: p, phi
===== Samplers =====
RW sampler (2)
  - phi
  - p
binary sampler (372)
  - z[]  (372 elements)</code></pre>
</div>
</div>
<p>Note that because we know with certainty that individuals were alive between the first and last survey they were captured, we can actually ease computation by supplying those <code>z[i, f[i]:l[i]]</code> as known. We’ll run this model to confirm that it’s able to recover our input parameters using <strong>MCMCvis</strong> <span class="citation" data-cites="youngflesh2018">(<a href="#ref-youngflesh2018" role="doc-biblioref">Youngflesh 2018</a>)</span>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># compile and build MCMC</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>Cmodel <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmodel)</span>
<span id="cb4-3"><a href="#cb4-3"></a>Cmcmc <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(conf) <span class="sc">|&gt;</span> <span class="fu">compileNimble</span>(<span class="at">project =</span> Cmodel, <span class="at">resetFunctions =</span> T)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"># fit model</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>n_iter <span class="ot">&lt;-</span> <span class="dv">500</span> ; n_chains <span class="ot">&lt;-</span> <span class="dv">8</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>fit_cmr_nimble <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc, <span class="at">niter =</span> n_iter <span class="sc">*</span> <span class="dv">2</span>, <span class="at">nburnin =</span> n_iter, <span class="at">nchains =</span> n_chains)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># summarise</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="fu">library</span>(MCMCvis)</span>
<span id="cb5-3"><a href="#cb5-3"></a>summary_cmr_nimble <span class="ot">&lt;-</span> <span class="fu">MCMCsummary</span>(fit_cmr_nimble, <span class="at">params =</span> <span class="fu">c</span>(<span class="st">"phi"</span>, <span class="st">"p"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="fu">as_tibble</span>(<span class="at">rownames =</span> <span class="st">"variable"</span>) <span class="sc">|&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(phi, p))</span>
<span id="cb5-6"><a href="#cb5-6"></a>summary_cmr_nimble</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 9
  variable  mean     sd `2.5%` `50%` `97.5%`  Rhat n.eff truth
  &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 phi      0.532 0.0415  0.452 0.530   0.621  1.02   549   0.6
2 p        0.711 0.0672  0.579 0.711   0.839  1.01   319   0.7</code></pre>
</div>
</div>
<p>As flexible as Bayesian software like BUGS and JAGS are, most of them do not use Hamiltonian Monte Carlo <span class="citation" data-cites="neal1994">(HMC, <a href="#ref-neal1994" role="doc-biblioref">Neal 1994</a>)</span> to generate samples from the posterior distribution (but see <a href="https://cran.r-project.org/web/packages/nimbleHMC/index.html"><strong>nimbleHMC</strong></a> for a recent implementation in NIMBLE). Without going into detail myself<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, HMC is considered a superior algorithm and moreover gives warnings when something goes wrong in the sampling, alerting the user to potential issues in estimation. As a result, HMC should generally be preferred by practitioners but it has one trait that can be challenging to ecologists in particular: it requires that all parameters are continuous, meaning that our typical state-space formulations of HMMs cannot be fit with HMC due to the presence of discrete parameters like our ecological states <code>z[i, j]</code> above. The remainder of this post will focus on dealing with fitting complex ecological models using <a href="https://mc-stan.org/">Stan</a> <span class="citation" data-cites="carpenter2017">(<a href="#ref-carpenter2017" role="doc-biblioref">Carpenter et al. 2017</a>)</span>, a probabilistic programming language which implements a <a href="https://mc-stan.org/docs/reference-manual/mcmc.html">state-of-the-art</a> No U-Turn Sampler <span class="citation" data-cites="hoffman2014">(NUTS, <a href="#ref-hoffman2014" role="doc-biblioref">Hoﬀman and Gelman 2014</a>)</span>. I present a unified approach that is applicable to simple and complex models alike, highlighted with three examples of increasing complexity.</p>
</section>
<section id="marginalisation" class="level2">
<h2 class="anchored" data-anchor-id="marginalisation">Marginalisation</h2>
<p>Since HMC cannot sample discrete parameters, we have to reformulate our models without the latent states through a process called marginalisation. Marginalisation essentially just counts the mutually exclusive ways an observation can be made and sums these probabilities, as <span class="math inline">\(\Pr(A \cup B) = \Pr(A) + \Pr(B)\)</span>. For instance, in the above mark-recapture example, consider an individual was captured on occasion 1 and recaptured on occasion 2. The only way this could have happened is that the individual survived the interval with probability <span class="math inline">\(\phi\)</span> <em>and</em> was recaptured on occasion 2 with probability <span class="math inline">\(p\)</span>, making the marginal likelihood of that datapoint <span class="math inline">\(\phi \cdot p\)</span>. However, if it was not observed at time 2, two things are possible: either the animal survived but was not recaptured with probability <span class="math inline">\(\phi \cdot (1 - p)\)</span> <em>or</em> the individual died with probability <span class="math inline">\(1 - \phi\)</span> and was thus not recaptured. Summing these probabilities gives us the marginal likelihood for that datapoint, which is <span class="math inline">\(\phi \cdot (1 - p) + (1 - \phi)\)</span>. Models can be marginalised in many different ways, but in this post I’m going to focus on the <a href="https://en.wikipedia.org/wiki/Forward_algorithm">forward algorithm</a>. Although it takes some getting used to, the forward algorithm facilitates fitting a wide variety of (increasingly complex) HMMs.</p>
<section id="forward-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="forward-algorithm">Forward algorithm</h3>
<p>First, I’m going to restructure our mark-recapture model as a multistate model with the introduction of <a href="https://en.wikipedia.org/wiki/Stochastic_matrix">transition probability matrices</a> (TPMs), which I denote as <span class="math inline">\(P\)</span> in the equations. In the mark-recapture example, we still have two latent ecological states, (1) alive and (2) dead. The transitions from one state to the other is given by the following TPM, where the states of departure (survey <span class="math inline">\(j - 1\)</span>) are in the rows and states of arrival (survey <span class="math inline">\(j\)</span>) are in the columns (note that the rows of a <em>row-stochastic</em> TPM must sum to 1):</p>
<p><span id="eq-P-z1"><span class="math display">\[
P_z = \begin{bmatrix}
  \phi &amp; 1 - \phi \\
  0 &amp; 1   
\end{bmatrix}
\tag{2}\]</span></span></p>
<p>Here, the dead state is an <a href="https://en.wikipedia.org/wiki/Absorbing_Markov_chain">absorbing state</a> and individuals remain in the alive states with probability <span class="math inline">\(\phi\)</span>. The observation process still deals with two observed states, (1) not detected and (2) detected, and is also formulated as a <span class="math inline">\(2 \cdot 2\)</span> TPM, where the ecological states are in the rows (states of departure) and the observed states in the columns (states of arrival):</p>
<p><span id="eq-P-y1"><span class="math display">\[
P_y = \begin{bmatrix}
  1 - p &amp; p \\
  1 &amp; 0
\end{bmatrix}
\tag{3}\]</span></span></p>
<p>The forward algorithm works by computing the marginal likelihood of an individual being in each state <span class="math inline">\(s \in 1 : S\)</span> at survey <span class="math inline">\(j\)</span> given the observations up to <span class="math inline">\(j\)</span>, stored in a <span class="math inline">\(S \cdot J\)</span> matrix we’ll call <span class="math inline">\(\Omega\)</span>. From here on, the notation for subsetting row <span class="math inline">\(i\)</span> of a matrix <span class="math inline">\(M\)</span> is <span class="math inline">\(M_i\)</span> and <span class="math inline">\(M_{:j}\)</span> for subsetting column <span class="math inline">\(j\)</span>. The forward algorithm starts from a vector of initial state probabilities, which in the mark-recapture example are known, given that we know with certainty that every individual is alive at first capture:</p>
<p><span id="eq-Omega-1"><span class="math display">\[
\Omega_{:{f_i}} = \left[ 1, 0 \right]^\intercal
\tag{4}\]</span></span></p>
<p>For subsequent occasions after an individual’s first capture <span class="math inline">\(j \in (f_i+1):J\)</span>, the marginal probabilities of being in state <span class="math inline">\(s\)</span> at time <span class="math inline">\(j\)</span> are computed as:</p>
<p><span id="eq-forward"><span class="math display">\[
\Omega_{:j} = P_z^\intercal \cdot \Omega_{:j-1} \odot {P_y}_{[:y_{i, j}]}
\tag{5}\]</span></span></p>
<p>That is, matrix multiplying the transposed ecological TPM wih the vector of marginal probabilities at time <span class="math inline">\(j-1\)</span> and then element-wise multiplying (where <span class="math inline">\(\odot\)</span> denotes the <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard or element-wise product</a>) the resulting vector with the relevant column of the observation TPM, where the first column is used if the individual was not observed (<span class="math inline">\(y_{i,j} = 1\)</span>) and the second column if it was observed (<span class="math inline">\(y_{i,j} = 2\)</span>). This process continues iteratively until survey <span class="math inline">\(J\)</span> after which the <a href="https://mc-stan.org/docs/reference-manual/statements.html#increment-log-prob.section">log density is incremented</a> with the log of the sum of <span class="math inline">\(\Omega_{:J}\)</span>, the marginal probabilities of being in each state at the end of the study period.</p>
</section>
<section id="posterior-distributions-for-the-discrete-parameters" class="level3">
<h3 class="anchored" data-anchor-id="posterior-distributions-for-the-discrete-parameters">Posterior distributions for the discrete parameters</h3>
<p>After marginalising the discrete variables from the model, we are frequently still interested in estimates for these quantities. For instance, in mark-recapture models we often want to estimate population sizes or in occupancy models we want to know the proportion of our sampled sites that were occupied. Ironically, we can actually get better estimates of the posterior distribution of the discrete variables after marginalising because of better exploration of the tails.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. In order to do so, we use the <em>backward algorithm</em> to generate a posterior distribution over the most likely state sequence. We start by sampling the most likely final state <span class="math inline">\(z_{i,J}\)</span> by sampling from the associated probabilities, which we can do in Stan using the <code>categorical_rng()</code> function after normalising them (dividing by the sum of the probabilities). Then we work backwards to compute the most likely state that came prior, by sampling from the probabilities given by the marginal probabilities of each state at time <span class="math inline">\(J-1\)</span> <em>and</em> having transitioned to state <span class="math inline">\(z_{i,J}\)</span>, <span class="math inline">\(\Omega_{:J-1} \odot {P_z}_{[:z_{i,J}]}\)</span>. We do this recursively until <span class="math inline">\(j=1\)</span> (or in case of mark-recapture, until the survey after the last capture, as we know the individual was alive until then).</p>
</section>
</section>
<section id="example-1-basic-mark-recapture-as-a-hmm" class="level2">
<h2 class="anchored" data-anchor-id="example-1-basic-mark-recapture-as-a-hmm">Example 1: Basic mark-recapture as a HMM</h2>
<p>As a first example of structuring ecological models as HMMs using the forward algorithm, I have translated the initial mark-recapture model for use in Stan. Stan programs specify a log density, so I wrote two versions, one with the probabilities which most closely resembles the above algebra and one using log probabilities throughout. Doing so involves swapping the multiplication of probabilities with summing the log probabilities, changing <code>log(sum())</code> to <a href="https://mc-stan.org/docs/stan-users-guide/floating-point.html#log-sum-of-exponentials"><code>log_sum_exp()</code></a>, and performing matrix multiplication on the log scale with a custom function <code>log_prod_exp()</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, which I found on <a href="https://stackoverflow.com/questions/36467022/handling-matrix-multiplication-in-log-space-in-python">Stack Overflow</a> (note that the function is overloaded to account for the dimensions of your two matrices). I have a few comments:</p>
<ul>
<li>Just like in the NIMBLE version, we don’t have to worry about the probabilities associated with being dead between the first and last capture. Note that for the occasions between first and last capture, I only compute the marginal probabilities of the alive state. At the occasion of last capture, I fix <span class="math inline">\(\Omega_{3,l_i}\)</span> to 0 (or <code>negative_infinity()</code> for log).</li>
<li>In all models, I also compute the site-level log likelihood in the vector <code>log_lik</code> for potential use in model checking using the <strong>loo</strong> package <span class="citation" data-cites="vehtari2023">(<a href="#ref-vehtari2023" role="doc-biblioref">Vehtari et al. 2023</a>)</span>.</li>
<li>Most parts of the <code>model</code> block are repeated in <code>generated quantities</code>. Although this makes the whole program more verbose, it is more efficient to compute derived quantities in the <code>generated quantities</code> block as they are only computed once per HMC iteration, whereas the <code>transformed parameters</code> and the <code>model</code> blocks get updated with each gradient evaluation, of which there can be many per iteration.</li>
</ul>
<section id="stan-programs" class="level3">
<h3 class="anchored" data-anchor-id="stan-programs">Stan programs</h3>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">Probabilities</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">Log Probabilities</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div class="cell" data-output.var="cmr_p">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">functions</span> {</span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="co">// normalise a vector of probabilities</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="dt">vector</span> normalise(<span class="dt">vector</span> A) {</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="cf">return</span> A / sum(A);</span>
<span id="cb7-5"><a href="#cb7-5"></a>  }</span>
<span id="cb7-6"><a href="#cb7-6"></a>}</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">data</span> {</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I, J;</span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J&gt; f;</span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=f, <span class="kw">upper</span>=J&gt; l;</span>
<span id="cb7-12"><a href="#cb7-12"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=<span class="dv">2</span>&gt; y;</span>
<span id="cb7-13"><a href="#cb7-13"></a>}</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="kw">parameters</span> {</span>
<span id="cb7-16"><a href="#cb7-16"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; phi, p;</span>
<span id="cb7-17"><a href="#cb7-17"></a>}</span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="kw">model</span> {</span>
<span id="cb7-20"><a href="#cb7-20"></a>  <span class="co">// priors</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>  <span class="kw">target +=</span> beta_lupdf(phi | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb7-22"><a href="#cb7-22"></a>  <span class="kw">target +=</span> beta_lupdf(p | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb7-23"><a href="#cb7-23"></a>  </span>
<span id="cb7-24"><a href="#cb7-24"></a>  <span class="co">// TPMs</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, <span class="dv">2</span>] P_z, P_y;</span>
<span id="cb7-26"><a href="#cb7-26"></a>  P_z = [[ phi, <span class="dv">1</span> - phi ],</span>
<span id="cb7-27"><a href="#cb7-27"></a>         [ <span class="dv">0</span>, <span class="dv">1</span> ]];</span>
<span id="cb7-28"><a href="#cb7-28"></a>  P_y = [[ <span class="dv">1</span> - p, p ],</span>
<span id="cb7-29"><a href="#cb7-29"></a>         [ <span class="dv">1</span>, <span class="dv">0</span> ]];</span>
<span id="cb7-30"><a href="#cb7-30"></a>  </span>
<span id="cb7-31"><a href="#cb7-31"></a>  <span class="co">// forward algorithm</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, J] Omega;</span>
<span id="cb7-33"><a href="#cb7-33"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb7-34"><a href="#cb7-34"></a>  </span>
<span id="cb7-35"><a href="#cb7-35"></a>    <span class="co">// initial state probabilities</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>    Omega[:, f[i]] = [ <span class="dv">1</span>, <span class="dv">0</span> ]';</span>
<span id="cb7-37"><a href="#cb7-37"></a>    </span>
<span id="cb7-38"><a href="#cb7-38"></a>    <span class="co">// must be alive up until last capture</span></span>
<span id="cb7-39"><a href="#cb7-39"></a>    <span class="cf">for</span> (j <span class="cf">in</span> (f[i] + <span class="dv">1</span>):l[i]) {</span>
<span id="cb7-40"><a href="#cb7-40"></a>      Omega[<span class="dv">1</span>, j] = P_z[<span class="dv">1</span>, <span class="dv">1</span>] * Omega[<span class="dv">1</span>, j - <span class="dv">1</span>] * P_y[<span class="dv">1</span>, y[i, j]];</span>
<span id="cb7-41"><a href="#cb7-41"></a>    }</span>
<span id="cb7-42"><a href="#cb7-42"></a>    Omega[<span class="dv">2</span>, l[i]] = <span class="dv">0</span>;</span>
<span id="cb7-43"><a href="#cb7-43"></a>    </span>
<span id="cb7-44"><a href="#cb7-44"></a>    <span class="co">// after last capture, condition both states on being undetected</span></span>
<span id="cb7-45"><a href="#cb7-45"></a>    <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):J) {</span>
<span id="cb7-46"><a href="#cb7-46"></a>      Omega[:, j] = P_z' * Omega[:, j - <span class="dv">1</span>] .* P_y[:, <span class="dv">1</span>];</span>
<span id="cb7-47"><a href="#cb7-47"></a>    }</span>
<span id="cb7-48"><a href="#cb7-48"></a>    </span>
<span id="cb7-49"><a href="#cb7-49"></a>    <span class="co">// increment log density</span></span>
<span id="cb7-50"><a href="#cb7-50"></a>    <span class="kw">target +=</span> log(sum(Omega[:, J]));</span>
<span id="cb7-51"><a href="#cb7-51"></a>  }</span>
<span id="cb7-52"><a href="#cb7-52"></a>}</span>
<span id="cb7-53"><a href="#cb7-53"></a></span>
<span id="cb7-54"><a href="#cb7-54"></a><span class="kw">generated quantities</span> {</span>
<span id="cb7-55"><a href="#cb7-55"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb7-56"><a href="#cb7-56"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span> z;</span>
<span id="cb7-57"><a href="#cb7-57"></a>  {</span>
<span id="cb7-58"><a href="#cb7-58"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, <span class="dv">2</span>] P_z, P_y;</span>
<span id="cb7-59"><a href="#cb7-59"></a>    P_z = [[ phi, <span class="dv">1</span> - phi ],</span>
<span id="cb7-60"><a href="#cb7-60"></a>           [ <span class="dv">0</span>, <span class="dv">1</span> ]];</span>
<span id="cb7-61"><a href="#cb7-61"></a>    P_y = [[ <span class="dv">1</span> - p, p ],</span>
<span id="cb7-62"><a href="#cb7-62"></a>           [ <span class="dv">1</span>, <span class="dv">0</span> ]];</span>
<span id="cb7-63"><a href="#cb7-63"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, J] Omega;</span>
<span id="cb7-64"><a href="#cb7-64"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb7-65"><a href="#cb7-65"></a>    </span>
<span id="cb7-66"><a href="#cb7-66"></a>      <span class="co">// forward algorithm for log likelihood</span></span>
<span id="cb7-67"><a href="#cb7-67"></a>      Omega[:, f[i]] = [ <span class="dv">1</span>, <span class="dv">0</span> ]';</span>
<span id="cb7-68"><a href="#cb7-68"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (f[i] + <span class="dv">1</span>):l[i]) {</span>
<span id="cb7-69"><a href="#cb7-69"></a>        Omega[<span class="dv">1</span>, j] = P_z[<span class="dv">1</span>, <span class="dv">1</span>] * Omega[<span class="dv">1</span>, j - <span class="dv">1</span>] * P_y[<span class="dv">1</span>, y[i, j]];</span>
<span id="cb7-70"><a href="#cb7-70"></a>      }</span>
<span id="cb7-71"><a href="#cb7-71"></a>      Omega[<span class="dv">2</span>, l[i]] = <span class="dv">0</span>;</span>
<span id="cb7-72"><a href="#cb7-72"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):J) {</span>
<span id="cb7-73"><a href="#cb7-73"></a>        Omega[:, j] = P_z' * Omega[:, j - <span class="dv">1</span>] .* P_y[:, <span class="dv">1</span>];</span>
<span id="cb7-74"><a href="#cb7-74"></a>      }</span>
<span id="cb7-75"><a href="#cb7-75"></a>      log_lik[i] = log(sum(Omega[:, J]));</span>
<span id="cb7-76"><a href="#cb7-76"></a>      </span>
<span id="cb7-77"><a href="#cb7-77"></a>      <span class="co">// backward algorithm for ecological states</span></span>
<span id="cb7-78"><a href="#cb7-78"></a>      z[i, J] = categorical_rng(normalise(Omega[:, J]));</span>
<span id="cb7-79"><a href="#cb7-79"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):(J - <span class="dv">1</span>)) {</span>
<span id="cb7-80"><a href="#cb7-80"></a>        <span class="dt">int</span> jj = J + l[i] - j;  <span class="co">// reverse indexing</span></span>
<span id="cb7-81"><a href="#cb7-81"></a>        z[i, jj] = categorical_rng(normalise(Omega[:, jj] </span>
<span id="cb7-82"><a href="#cb7-82"></a>                                             .* P_z[:, z[i, jj + <span class="dv">1</span>]]));</span>
<span id="cb7-83"><a href="#cb7-83"></a>      }</span>
<span id="cb7-84"><a href="#cb7-84"></a>      <span class="co">// alive from first to last capture</span></span>
<span id="cb7-85"><a href="#cb7-85"></a>      z[i, f[i]:l[i]] = ones_int_array(l[i] - f[i] + <span class="dv">1</span>);</span>
<span id="cb7-86"><a href="#cb7-86"></a>    }</span>
<span id="cb7-87"><a href="#cb7-87"></a>  }</span>
<span id="cb7-88"><a href="#cb7-88"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<div class="cell" data-output.var="cmr_lp">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">functions</span>{</span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="co">// normalise a vector of log probabilities</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="dt">vector</span> normalise_log(<span class="dt">vector</span> A) {</span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="cf">return</span> A - log_sum_exp(A);</span>
<span id="cb8-5"><a href="#cb8-5"></a>  }</span>
<span id="cb8-6"><a href="#cb8-6"></a>  </span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="co">/**</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">   * Return the natural logarithm of the product of the element-wise </span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">   * exponentiation of the specified matrices</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">   *</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> A  First matrix or (row_)vector</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> B  Second matrix or (row_)vector</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co">   *</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="co">   * </span><span class="an">@return</span><span class="co">   log(exp(A) * exp(B))</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">   */</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>  <span class="dt">matrix</span> log_prod_exp(<span class="dt">matrix</span> A, <span class="dt">matrix</span> B) {</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb8-18"><a href="#cb8-18"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="dt">int</span> K = cols(B);</span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="dt">matrix</span>[J, I] A_tr = A';</span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="dt">matrix</span>[I, K] C;</span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb8-23"><a href="#cb8-23"></a>      <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb8-24"><a href="#cb8-24"></a>        C[i, k] = log_sum_exp(A_tr[:, i] + B[:, k]);</span>
<span id="cb8-25"><a href="#cb8-25"></a>      }</span>
<span id="cb8-26"><a href="#cb8-26"></a>    }</span>
<span id="cb8-27"><a href="#cb8-27"></a>    <span class="cf">return</span> C;</span>
<span id="cb8-28"><a href="#cb8-28"></a>  }</span>
<span id="cb8-29"><a href="#cb8-29"></a>  <span class="dt">vector</span> log_prod_exp(<span class="dt">matrix</span> A, <span class="dt">vector</span> B) {</span>
<span id="cb8-30"><a href="#cb8-30"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb8-31"><a href="#cb8-31"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb8-32"><a href="#cb8-32"></a>    <span class="dt">matrix</span>[J, I] A_tr = A';</span>
<span id="cb8-33"><a href="#cb8-33"></a>    <span class="dt">vector</span>[I] C;</span>
<span id="cb8-34"><a href="#cb8-34"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb8-35"><a href="#cb8-35"></a>      C[i] = log_sum_exp(A_tr[:, i] + B);</span>
<span id="cb8-36"><a href="#cb8-36"></a>    }</span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="cf">return</span> C;</span>
<span id="cb8-38"><a href="#cb8-38"></a>  }</span>
<span id="cb8-39"><a href="#cb8-39"></a>  <span class="dt">row_vector</span> log_prod_exp(<span class="dt">row_vector</span> A, <span class="dt">matrix</span> B) {</span>
<span id="cb8-40"><a href="#cb8-40"></a>    <span class="dt">int</span> K = cols(B);</span>
<span id="cb8-41"><a href="#cb8-41"></a>    <span class="dt">vector</span>[size(A)] A_tr = A';</span>
<span id="cb8-42"><a href="#cb8-42"></a>    <span class="dt">row_vector</span>[K] C;</span>
<span id="cb8-43"><a href="#cb8-43"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb8-44"><a href="#cb8-44"></a>      C[k] = log_sum_exp(A_tr + B[:, k]);</span>
<span id="cb8-45"><a href="#cb8-45"></a>    }</span>
<span id="cb8-46"><a href="#cb8-46"></a>    <span class="cf">return</span> C;</span>
<span id="cb8-47"><a href="#cb8-47"></a>  }</span>
<span id="cb8-48"><a href="#cb8-48"></a>  <span class="dt">real</span> log_prod_exp(<span class="dt">row_vector</span> A, <span class="dt">vector</span> B) {</span>
<span id="cb8-49"><a href="#cb8-49"></a>    <span class="cf">return</span> log_sum_exp(A' + B);</span>
<span id="cb8-50"><a href="#cb8-50"></a>  }</span>
<span id="cb8-51"><a href="#cb8-51"></a>}</span>
<span id="cb8-52"><a href="#cb8-52"></a></span>
<span id="cb8-53"><a href="#cb8-53"></a><span class="kw">data</span> {</span>
<span id="cb8-54"><a href="#cb8-54"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I, J;</span>
<span id="cb8-55"><a href="#cb8-55"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J - <span class="dv">1</span>&gt; f;</span>
<span id="cb8-56"><a href="#cb8-56"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=f, <span class="kw">upper</span>=J&gt; l;</span>
<span id="cb8-57"><a href="#cb8-57"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=<span class="dv">2</span>&gt; y;</span>
<span id="cb8-58"><a href="#cb8-58"></a>}</span>
<span id="cb8-59"><a href="#cb8-59"></a></span>
<span id="cb8-60"><a href="#cb8-60"></a><span class="kw">parameters</span> {</span>
<span id="cb8-61"><a href="#cb8-61"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; phi, p;</span>
<span id="cb8-62"><a href="#cb8-62"></a>}</span>
<span id="cb8-63"><a href="#cb8-63"></a></span>
<span id="cb8-64"><a href="#cb8-64"></a><span class="kw">model</span> {</span>
<span id="cb8-65"><a href="#cb8-65"></a>  <span class="co">// priors</span></span>
<span id="cb8-66"><a href="#cb8-66"></a>  <span class="kw">target +=</span> beta_lupdf(phi | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb8-67"><a href="#cb8-67"></a>  <span class="kw">target +=</span> beta_lupdf(p | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb8-68"><a href="#cb8-68"></a>  </span>
<span id="cb8-69"><a href="#cb8-69"></a>  <span class="co">// (log) TPMs</span></span>
<span id="cb8-70"><a href="#cb8-70"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, <span class="dv">2</span>] P_z, P_y;</span>
<span id="cb8-71"><a href="#cb8-71"></a>  P_z = [[ phi, <span class="dv">1</span> - phi ],</span>
<span id="cb8-72"><a href="#cb8-72"></a>         [ <span class="dv">0</span>, <span class="dv">1</span> ]];</span>
<span id="cb8-73"><a href="#cb8-73"></a>  P_y = [[ <span class="dv">1</span> - p, p ],</span>
<span id="cb8-74"><a href="#cb8-74"></a>         [ <span class="dv">1</span>, <span class="dv">0</span> ]];</span>
<span id="cb8-75"><a href="#cb8-75"></a>  P_z = log(P_z);</span>
<span id="cb8-76"><a href="#cb8-76"></a>  P_y = log(P_y);</span>
<span id="cb8-77"><a href="#cb8-77"></a>  </span>
<span id="cb8-78"><a href="#cb8-78"></a>  <span class="co">// forward algorithm</span></span>
<span id="cb8-79"><a href="#cb8-79"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, J] Omega;</span>
<span id="cb8-80"><a href="#cb8-80"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb8-81"><a href="#cb8-81"></a>    </span>
<span id="cb8-82"><a href="#cb8-82"></a>    <span class="co">// initial state log probabilities</span></span>
<span id="cb8-83"><a href="#cb8-83"></a>    Omega[:, f[i]] = [ <span class="dv">0</span>, negative_infinity() ]';</span>
<span id="cb8-84"><a href="#cb8-84"></a>    </span>
<span id="cb8-85"><a href="#cb8-85"></a>    <span class="co">// must be alive up until last capture</span></span>
<span id="cb8-86"><a href="#cb8-86"></a>    <span class="cf">for</span> (j <span class="cf">in</span> (f[i] + <span class="dv">1</span>):l[i]) {</span>
<span id="cb8-87"><a href="#cb8-87"></a>      Omega[<span class="dv">1</span>, j] = P_z[<span class="dv">1</span>, <span class="dv">1</span>] + Omega[<span class="dv">1</span>, j - <span class="dv">1</span>] + P_y[<span class="dv">1</span>, y[i, j]];</span>
<span id="cb8-88"><a href="#cb8-88"></a>    }</span>
<span id="cb8-89"><a href="#cb8-89"></a>    Omega[<span class="dv">2</span>, l[i]] = negative_infinity();</span>
<span id="cb8-90"><a href="#cb8-90"></a>      </span>
<span id="cb8-91"><a href="#cb8-91"></a>    <span class="co">// after last capture, condition both states on being undetected</span></span>
<span id="cb8-92"><a href="#cb8-92"></a>    <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):J) {</span>
<span id="cb8-93"><a href="#cb8-93"></a>      Omega[:, j] = log_prod_exp(P_z', Omega[:, j - <span class="dv">1</span>]) + P_y[:, <span class="dv">1</span>];</span>
<span id="cb8-94"><a href="#cb8-94"></a>    }</span>
<span id="cb8-95"><a href="#cb8-95"></a>    </span>
<span id="cb8-96"><a href="#cb8-96"></a>    <span class="co">// increment log density</span></span>
<span id="cb8-97"><a href="#cb8-97"></a>    <span class="kw">target +=</span> log_sum_exp(Omega[:, J]);</span>
<span id="cb8-98"><a href="#cb8-98"></a>  }</span>
<span id="cb8-99"><a href="#cb8-99"></a>}</span>
<span id="cb8-100"><a href="#cb8-100"></a></span>
<span id="cb8-101"><a href="#cb8-101"></a><span class="kw">generated quantities</span> {</span>
<span id="cb8-102"><a href="#cb8-102"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span> z;</span>
<span id="cb8-103"><a href="#cb8-103"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb8-104"><a href="#cb8-104"></a>  {</span>
<span id="cb8-105"><a href="#cb8-105"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, <span class="dv">2</span>] P_z, P_y;</span>
<span id="cb8-106"><a href="#cb8-106"></a>    P_z = [[ phi, <span class="dv">1</span> - phi ],</span>
<span id="cb8-107"><a href="#cb8-107"></a>           [ <span class="dv">0</span>, <span class="dv">1</span> ]];</span>
<span id="cb8-108"><a href="#cb8-108"></a>    P_y = [[ <span class="dv">1</span> - p, p ],</span>
<span id="cb8-109"><a href="#cb8-109"></a>           [ <span class="dv">1</span>, <span class="dv">0</span> ]];</span>
<span id="cb8-110"><a href="#cb8-110"></a>    P_z = log(P_z);</span>
<span id="cb8-111"><a href="#cb8-111"></a>    P_y = log(P_y);</span>
<span id="cb8-112"><a href="#cb8-112"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, J] Omega;</span>
<span id="cb8-113"><a href="#cb8-113"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb8-114"><a href="#cb8-114"></a>    </span>
<span id="cb8-115"><a href="#cb8-115"></a>      <span class="co">// forward algorithm for log likelihood</span></span>
<span id="cb8-116"><a href="#cb8-116"></a>      Omega[:, f[i]] = [ <span class="dv">0</span>, negative_infinity() ]';</span>
<span id="cb8-117"><a href="#cb8-117"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (f[i] + <span class="dv">1</span>):l[i]) {</span>
<span id="cb8-118"><a href="#cb8-118"></a>        Omega[<span class="dv">1</span>, j] = P_z[<span class="dv">1</span>, <span class="dv">1</span>] + Omega[<span class="dv">1</span>, j - <span class="dv">1</span>] + P_y[<span class="dv">1</span>, y[i, j]];</span>
<span id="cb8-119"><a href="#cb8-119"></a>      }</span>
<span id="cb8-120"><a href="#cb8-120"></a>      Omega[<span class="dv">2</span>, l[i]] = negative_infinity();</span>
<span id="cb8-121"><a href="#cb8-121"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):J) {</span>
<span id="cb8-122"><a href="#cb8-122"></a>        Omega[:, j] = log_prod_exp(P_z', Omega[:, j - <span class="dv">1</span>]) + P_y[:, <span class="dv">1</span>];</span>
<span id="cb8-123"><a href="#cb8-123"></a>      }</span>
<span id="cb8-124"><a href="#cb8-124"></a>      log_lik[i] = log_sum_exp(Omega[:, J]);</span>
<span id="cb8-125"><a href="#cb8-125"></a>      </span>
<span id="cb8-126"><a href="#cb8-126"></a>      <span class="co">// backward algorithm for ecological states</span></span>
<span id="cb8-127"><a href="#cb8-127"></a>      z[i, J] = categorical_rng(exp(normalise_log(Omega[:, J])));</span>
<span id="cb8-128"><a href="#cb8-128"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):(J - <span class="dv">1</span>)) {</span>
<span id="cb8-129"><a href="#cb8-129"></a>        <span class="dt">int</span> jj = J + l[i] - j;  <span class="co">// reverse indexing</span></span>
<span id="cb8-130"><a href="#cb8-130"></a>        z[i, jj] = categorical_rng(exp(normalise_log(Omega[:, jj] </span>
<span id="cb8-131"><a href="#cb8-131"></a>                                                     + P_z[:, z[i, jj + <span class="dv">1</span>]])));</span>
<span id="cb8-132"><a href="#cb8-132"></a>      }</span>
<span id="cb8-133"><a href="#cb8-133"></a>      <span class="co">// alive from first to last capture</span></span>
<span id="cb8-134"><a href="#cb8-134"></a>      z[i, f[i]:l[i]] = ones_int_array(l[i] - f[i] + <span class="dv">1</span>);</span>
<span id="cb8-135"><a href="#cb8-135"></a>    }</span>
<span id="cb8-136"><a href="#cb8-136"></a>  }</span>
<span id="cb8-137"><a href="#cb8-137"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
</div>
</section>
<section id="why-we-like-hmc" class="level3">
<h3 class="anchored" data-anchor-id="why-we-like-hmc">Why we like HMC</h3>
<p>Using <strong>CmdStanR</strong> 0.7.1 to call CmdStan 2.34.1 <span class="citation" data-cites="gabry2023">(<a href="#ref-gabry2023" role="doc-biblioref">Gabry et al. 2023</a>)</span>, we’ll just run the log probability model for the same number of iterations as the NIMBLE version, and we see that there were no issues with sampling (Stan would tell us otherwise) and the effective sample sizes (ESS) were several times higher than for the NIMBLE model.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># data for Stan without NAs</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>cmr_data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J =</span> J, <span class="at">f =</span> f, <span class="at">l =</span> l, <span class="at">y =</span> y <span class="sc">+</span> <span class="dv">1</span>) <span class="sc">|&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="fu">sapply</span>(\(x) <span class="fu">replace</span>(x, <span class="fu">is.na</span>(x), <span class="dv">1</span>))</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co"># run HMC</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="fu">library</span>(cmdstanr)</span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="fu">options</span>(<span class="at">mc.cores =</span> n_chains)</span>
<span id="cb9-8"><a href="#cb9-8"></a>fit_cmr <span class="ot">&lt;-</span> cmr_lp<span class="sc">$</span><span class="fu">sample</span>(<span class="at">data =</span> cmr_data, <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> n_chains, </span>
<span id="cb9-9"><a href="#cb9-9"></a>                         <span class="at">iter_warmup =</span> n_iter, <span class="at">iter_sampling =</span> n_iter)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...

Chain 1 finished in 1.3 seconds.
Chain 2 finished in 1.4 seconds.
Chain 4 finished in 1.3 seconds.
Chain 6 finished in 1.3 seconds.
Chain 7 finished in 1.3 seconds.
Chain 3 finished in 1.4 seconds.
Chain 5 finished in 1.4 seconds.
Chain 8 finished in 1.3 seconds.

All 8 chains finished successfully.
Mean chain execution time: 1.3 seconds.
Total execution time: 1.6 seconds.</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># summary</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb11-3"><a href="#cb11-3"></a>fit_cmr<span class="sc">$</span><span class="fu">summary</span>(<span class="fu">c</span>(<span class="st">"phi"</span>, <span class="st">"p"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="fu">select</span>(variable, median, <span class="fu">contains</span>(<span class="st">"q"</span>), <span class="fu">contains</span>(<span class="st">"ess"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>  <span class="fu">mutate</span>(<span class="at">ess_nimble =</span> summary_cmr_nimble<span class="sc">$</span>n.eff,</span>
<span id="cb11-6"><a href="#cb11-6"></a>         <span class="at">truth =</span> <span class="fu">c</span>(phi, p))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 8
  variable median    q5   q95 ess_bulk ess_tail ess_nimble truth
  &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;
1 phi       0.529 0.459 0.596    2127.    2315.        549   0.6
2 p         0.719 0.599 0.819    2084.    2219.        319   0.7</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># check loo</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>fit_cmr<span class="sc">$</span><span class="fu">loo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Computed from 4000 by 100 log-likelihood matrix.

         Estimate   SE
elpd_loo   -151.1 14.8
p_loo         2.2  0.7
looic       302.2 29.7
------
MCSE of elpd_loo is 0.0.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.4, 1.0]).

All Pareto k estimates are good (k &lt; 0.7).
See help('pareto-k-diagnostic') for details.</code></pre>
</div>
</div>
<p>And just to confirm, we check if the backward algorithm was able to closely recover the latent alive states. In order to assess this fairly, I’ll only check what proportion of the ambiguous states (i.e., after last capture) was estimated correctly, based on the posterior medians.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="fu">library</span>(tidybayes)</span>
<span id="cb15-2"><a href="#cb15-2"></a>fit_cmr <span class="sc">|&gt;</span> </span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="fu">spread_rvars</span>(z[i, j]) <span class="sc">|&gt;</span> </span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="fu">left_join</span>(<span class="fu">tibble</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>I, </span>
<span id="cb15-5"><a href="#cb15-5"></a>                   <span class="at">l =</span> l), </span>
<span id="cb15-6"><a href="#cb15-6"></a>            <span class="at">by =</span> <span class="st">"i"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb15-7"><a href="#cb15-7"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">if_else</span>(<span class="fu">c</span>(.env<span class="sc">$</span>z) <span class="sc">==</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb15-8"><a href="#cb15-8"></a>  <span class="fu">filter</span>(j <span class="sc">&gt;</span> l) <span class="sc">|&gt;</span> </span>
<span id="cb15-9"><a href="#cb15-9"></a>  <span class="fu">summarise</span>(<span class="at">prop_true =</span> <span class="fu">mean</span>(<span class="fu">median</span>(z) <span class="sc">==</span> truth))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 1
  prop_true
      &lt;dbl&gt;
1     0.944</code></pre>
</div>
</div>
</section>
</section>
<section id="example-2-dynamic-multistate-occupancy-model" class="level2">
<h2 class="anchored" data-anchor-id="example-2-dynamic-multistate-occupancy-model">Example 2: Dynamic multistate occupancy model</h2>
<p>In order to highlight the generality of the above modeling approach, we’re going to switch gears to a dynamic occupancy model. There are some trivial to implement differences with the basic mark-recapture model that can seem daunting at first:</p>
<ul>
<li>There can be more than two states.</li>
<li>The initial state probabilities here are unknown, that is, we don’t know the occupancy state of a site when it’s first surveyed.</li>
<li>State transitions can happen in more than one direction, whereas dead individuals in mark-recapture can never transition to alive (i.e., there is no absorbing state).</li>
</ul>
<p>Consider a study area containing sites <span class="math inline">\(i \in 1 : I\)</span> surveyed across seasons <span class="math inline">\(j \in 1 : J\)</span>. We are investigating whether sites are occupied by tiger snakes (<em>Notechis scutatus</em>) in each season, but want to differentiate between sites that simply support tiger snakes or those that support breeding. Our ecological process thus has three possible states: (1) unoccupied by tiger snakes, (2) occupied by tiger snakes but not for breeding, or (3) occupied by breeding tiger snakes. The observation process also has three possible states: (1) no snakes found, (2) snakes found but no evidence of breeding, and (3) snakes found with evidence of breeding, as determined by the discovery of gravid females. Instead of directly formulating the ecological TPM here, we’ll do it in continuous time instead using a <a href="https://en.m.wikipedia.org/wiki/Transition-rate_matrix">transition <em>rate</em> matrix</a> (TRM), which I call <span class="math inline">\(Q\)</span> in the equations. Although this may not be the best example for use with a continuous time model, I think it comes up often enough in these ecological models to warrant a demonstration.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/tiger.jpg" class="img-fluid figure-img" style="width:88.6%"></p>
<figcaption>A rainforest tiger snake (<em>Notechis scutatus</em>) from northern New South Wales, Australia.</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Ecology occurs in continuous time
</div>
</div>
<div class="callout-body-container callout-body">
<p>TPMs assume equal intervals between surveys, but this is the exception rather than the norm for ecological data. Although things like survival probabilities can easily be exponentiated to the time interval, this doesn’t work for processes that are not absorbing states, i.e., snakes moving in and out of sites. Unlike individual survival, sites are free to transition between states from year to year. Even with simpler models, however, it often makes more sense to model the survival process with mortality hazard rates (where the survival probability <span class="math inline">\(S\)</span> is related to the mortality hazard rate <span class="math inline">\(h\)</span> as <span class="math inline">\(S = \exp(-h)\)</span>) for a number of reasons <span class="citation" data-cites="ergon2018">(<a href="#ref-ergon2018" role="doc-biblioref">Ergon et al. 2018</a>)</span>. The multistate extension of this is straightforward, where we instead take the matrix exponential of a TRM <span class="citation" data-cites="glennie2022">(<a href="#ref-glennie2022" role="doc-biblioref">Glennie et al. 2022</a>)</span>. By constructing our transition matrices as TRMs, where the off-diagonals contain instantaneous hazard rates and the diagonals contain negative sums of these off-diagonals (ensuring rows sum to 0, not 1), we can generate time-specific TPMs by taking the matrix exponential of the TRM multiplied by the time interval between occasions (<span class="math inline">\(\tau_j\)</span>), thereby essentially marginalising over possible state transitions that occurred during survey intervals:</p>
<p><span id="eq-trm"><span class="math display">\[
{P_z}_{[j]} = \exp \left( Q \cdot \tau_j \right)
\tag{6}\]</span></span></p>
</div>
</div>
<p>A TRM for the tiger snake example might look something like this, with again states of departure (season <span class="math inline">\(j-1\)</span>) in the rows and states of arrival (season <span class="math inline">\(j\)</span>) in the columns:</p>
<p><span id="eq-trm2"><span class="math display">\[
Q = \begin{bmatrix}
  -(\gamma_1 + \gamma_2) &amp; \gamma_1 &amp; \gamma_2 \\
  \epsilon_1 &amp; -(\epsilon_1 + \psi_1) &amp; \psi_1 \\
  \epsilon_2 &amp; \psi_2 &amp; -(\epsilon_2 + \psi_2)
\end{bmatrix}
\tag{7}\]</span></span> with the following parameters:</p>
<ul>
<li><span class="math inline">\(\gamma_1\)</span>: the “non-breeding” colonisation rate, or the rate at which a site becomes occupied with non-breeding snakes at time <span class="math inline">\(j\)</span> when the site was not occupied at time <span class="math inline">\(j - 1\)</span>.</li>
<li><span class="math inline">\(\gamma_2\)</span>: the “breeding” colonisation rate, or the rate at which a site becomes occupied with breeding snakes at time <span class="math inline">\(j\)</span> when the site was not occupied at time <span class="math inline">\(j - 1\)</span>.</li>
<li><span class="math inline">\(\epsilon_1\)</span>: the “non-breeding” emigration rate, or the rate at which a site becomes onoccupied at time <span class="math inline">\(j\)</span> when it was occupied with non-breeding snakes at time <span class="math inline">\(j - 1\)</span>.</li>
<li><span class="math inline">\(\epsilon_2\)</span>: the “breeding” emigration rate, or the rate at which a site becomes onoccupied at time <span class="math inline">\(j\)</span> when it was occupied with breeding snakes at time <span class="math inline">\(j - 1\)</span>.</li>
<li><span class="math inline">\(\psi_1\)</span>: the breeding rate, or the rate at which a site becomes used for breeding at time <span class="math inline">\(j\)</span> when the site was occupied but not used for breeding at time <span class="math inline">\(j - 1\)</span>.</li>
<li><span class="math inline">\(\psi_2\)</span>: the breeding cessation rate, or the rate at which a site stops being used for breeding at time <span class="math inline">\(j\)</span> when the site was used for breeding at time <span class="math inline">\(j - 1\)</span>.</li>
</ul>
<p>Note that even if these parameters aren’t exactly the quantities of interest, derivations of these parameters are easily produced as generated quantities after parameter estimation. Of course, these parameters can be modeled more complexly with linear or non-linear effects at the level of years, sites, or both, with the only changes being that the TRMs are constructed at those levels (for instance, by creating site- and year-level TRMs where the parameters populating the TRM are allowed to vary at that level—see Example 3 for an application).</p>
<p>In addition to the TRM/TPM, the ecological process is initiated on the first occasion with an initial state vector, giving the probabilities of being in each state at <span class="math inline">\(j = 1\)</span>:</p>
<p><span id="eq-eta"><span class="math display">\[
  \boldsymbol{\eta} = \left[ \eta_1 , \eta_2 , \eta_3 \right]
\tag{8}\]</span></span></p>
<section id="simulating-continuous-time" class="level3">
<h3 class="anchored" data-anchor-id="simulating-continuous-time">Simulating continuous time</h3>
<p>Below, I’ll simulate the ecological data by specifying a TRM and using the <strong>expm</strong> package to take the matrix exponential to generate the TPMs <span class="citation" data-cites="goulet2021">(<a href="#ref-goulet2021" role="doc-biblioref">Goulet et al. 2021</a>)</span>. In order to simulate ecological states <code>z[i, j]</code> we use the categorical distribution, which is just the Bernoulli distribution generalised to multiple outcomes. I demonstrate the ability to accommodate unequal time intervals with the TRM.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># metadata</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>I <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>J <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>K_max <span class="ot">&lt;-</span> <span class="dv">4</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>tau <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(J <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb17-6"><a href="#cb17-6"></a></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="co"># parameters</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>eta <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>)       <span class="co"># unoccupied/non-breeding/breeding initial probabilities</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>eta[<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">sum</span>(eta[<span class="dv">2</span><span class="sc">:</span><span class="dv">3</span>])  <span class="co"># ensure probabilities sum to 1 (simplex) </span></span>
<span id="cb17-10"><a href="#cb17-10"></a>gamma <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">0.2</span>)         <span class="co"># non-breeding/breeding colonisation rates</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>epsilon <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="fl">0.1</span>)       <span class="co"># non-breeding/breeding emigration rates</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>psi <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="fl">0.3</span>)           <span class="co"># breeding/breeding cessation rates</span></span>
<span id="cb17-13"><a href="#cb17-13"></a></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="co"># function for random categorical draw</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>rcat <span class="ot">&lt;-</span> <span class="cf">function</span>(n, prob) {</span>
<span id="cb17-16"><a href="#cb17-16"></a>  <span class="fu">return</span>(</span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="fu">rmultinom</span>(n, <span class="at">size =</span> <span class="dv">1</span>, prob) <span class="sc">|&gt;</span> </span>
<span id="cb17-18"><a href="#cb17-18"></a>      <span class="fu">apply</span>(<span class="dv">2</span>, \(x) <span class="fu">which</span>(x <span class="sc">==</span> <span class="dv">1</span>))</span>
<span id="cb17-19"><a href="#cb17-19"></a>  )</span>
<span id="cb17-20"><a href="#cb17-20"></a>}</span>
<span id="cb17-21"><a href="#cb17-21"></a></span>
<span id="cb17-22"><a href="#cb17-22"></a><span class="co"># TRM</span></span>
<span id="cb17-23"><a href="#cb17-23"></a>Q <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="sc">-</span>(gamma[<span class="dv">1</span>] <span class="sc">+</span> gamma[<span class="dv">2</span>]), gamma[<span class="dv">1</span>], gamma[<span class="dv">2</span>],</span>
<span id="cb17-24"><a href="#cb17-24"></a>              epsilon[<span class="dv">1</span>], <span class="sc">-</span>(epsilon[<span class="dv">1</span>] <span class="sc">+</span> psi[<span class="dv">1</span>]), psi[<span class="dv">1</span>],</span>
<span id="cb17-25"><a href="#cb17-25"></a>              epsilon[<span class="dv">2</span>], psi[<span class="dv">2</span>], <span class="sc">-</span>(epsilon[<span class="dv">2</span>] <span class="sc">+</span> psi[<span class="dv">2</span>])),</span>
<span id="cb17-26"><a href="#cb17-26"></a>            <span class="dv">3</span>, <span class="at">byrow =</span> T)</span>
<span id="cb17-27"><a href="#cb17-27"></a>Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3]
[1,] -0.5  0.3  0.2
[2,]  0.4 -0.8  0.4
[3,]  0.1  0.3 -0.4</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># here's the TPMs</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="fu">library</span>(expm)</span>
<span id="cb19-3"><a href="#cb19-3"></a>P_z <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(J <span class="sc">-</span> <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>J) {</span>
<span id="cb19-5"><a href="#cb19-5"></a>  P_z[j <span class="sc">-</span> <span class="dv">1</span>, , ] <span class="ot">&lt;-</span> <span class="fu">expm</span>(Q <span class="sc">*</span> tau[j <span class="sc">-</span> <span class="dv">1</span>])</span>
<span id="cb19-6"><a href="#cb19-6"></a>}</span>
<span id="cb19-7"><a href="#cb19-7"></a>P_z[<span class="dv">1</span>, , ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>       [,1]  [,2]   [,3]
[1,] 0.9036 0.056 0.0404
[2,] 0.0739 0.851 0.0754
[3,] 0.0214 0.056 0.9226</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="co"># ecological process simulation</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>z <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, I, J)</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb21-4"><a href="#cb21-4"></a>  z[i, <span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">1</span>, eta)</span>
<span id="cb21-5"><a href="#cb21-5"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>J) {</span>
<span id="cb21-6"><a href="#cb21-6"></a>    z[i, j] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">1</span>, P_z[j <span class="sc">-</span> <span class="dv">1</span>, z[i, j <span class="sc">-</span> <span class="dv">1</span>], ])</span>
<span id="cb21-7"><a href="#cb21-7"></a>  }</span>
<span id="cb21-8"><a href="#cb21-8"></a>}</span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="fu">head</span>(z, <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    1    1    1    2    1    1    1    2    2     3
 [2,]    2    2    3    3    1    1    3    2    1     1
 [3,]    1    1    2    3    2    2    3    1    1     2
 [4,]    3    3    2    3    1    1    3    3    3     3
 [5,]    3    3    3    3    2    1    1    1    1     3
 [6,]    1    1    3    2    3    2    1    1    1     1
 [7,]    3    3    2    2    1    2    3    3    2     3
 [8,]    3    3    3    3    3    2    2    2    2     2
 [9,]    1    1    2    2    3    3    3    1    3     3
[10,]    3    3    3    3    2    2    2    3    3     1</code></pre>
</div>
</div>
</section>
<section id="observation-process" class="level3">
<h3 class="anchored" data-anchor-id="observation-process">Observation process</h3>
<p>Although possible to construct in continuous time, often our observation model makes more sense in discrete time, especially if specific surveys were conducted instead of with something like an automated recording device. For instance, with dynamic occupancy models, an investigator would conduct multiple “secondary” surveys <span class="math inline">\(k \in 1:K_{ij}\)</span> within a season in order to disentangle the ecological process from the observation process.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Robust Design
</div>
</div>
<div class="callout-body-container callout-body">
<p>With multistate models where individuals or sites can transition between ecological states, in order to reliably estimate transitions rates and detection probabilities we need to conduct multiple consecutive surveys within periods of assumed closure, yielding secondary surveys nested within primary occasions. In the absence of this, there are <a href="https://besjournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1111%2F2041-210X.13993&amp;file=mee313993-sup-0004-appendixS4-comparison.pdf">parameter identifiability issues</a> for the state transition rates and state-specific detection probabilities. This survey strategy was originally called the “robust design” <span class="citation" data-cites="pollock1982">(<a href="#ref-pollock1982" role="doc-biblioref">Pollock 1982</a>)</span> and the necessity of applying it for multistate models more generally has gone largely unappreciated by ecologists.</p>
</div>
</div>
<p>As in the mark-recapture example, we construct an observation TPM where the ecological states are in the rows and observed states in the columns, recognising that there’s uncertainty in being able to detect breeding:</p>
<p><span id="eq-P-y2"><span class="math display">\[
P_y = \begin{bmatrix}
  1 &amp; 0 &amp; 0 \\
  1 - p_1 &amp; p_1 &amp; 0 \\
  1 - p_2 &amp; p_2 \cdot (1 - \delta) &amp; p_2 \cdot \delta
\end{bmatrix}
\tag{9}\]</span></span> with the following parameters:</p>
<ul>
<li><span class="math inline">\(p_{1:2}\)</span>: the state-specific detection probabilities, or the probabilities of detecting tiger snakes if they are present but not breeding (<span class="math inline">\(p_1\)</span>) or present and breeding (<span class="math inline">\(p_2\)</span>).</li>
<li><span class="math inline">\(\delta\)</span>: the breeding detection probability, or the probability of detecting tiger snake breeding conditional on it occurring at a site. Note that in this example, breeding is detected when gravid females are found. Note that false-positive detections of any kind (erroneous snake identification, etc.) are not considered, but will be in Example 3.</li>
</ul>
<p>I’ll simulate some observational data below where the investigators aimed to conduct 4 secondary surveys per site and primary occasion (<span class="math inline">\(K_{i,j}\)</span>), all conducted during the tiger snake breeding season, with some secondary surveys missed, and some years missed altogether (simulated as <span class="math inline">\(K_{i,j} = 0\)</span>).</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># parameters</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>p <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="fl">0.5</span>)  <span class="co"># non-breeding/breeding detection probabilities</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>delta <span class="ot">&lt;-</span> <span class="fl">0.6</span>      <span class="co"># breeding detection probability</span></span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="co"># TPM</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>P_y <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb23-7"><a href="#cb23-7"></a>                <span class="dv">1</span> <span class="sc">-</span> p[<span class="dv">1</span>], p[<span class="dv">1</span>], <span class="dv">0</span>,</span>
<span id="cb23-8"><a href="#cb23-8"></a>                <span class="dv">1</span> <span class="sc">-</span> p[<span class="dv">2</span>], p[<span class="dv">2</span>] <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> delta), p[<span class="dv">2</span>] <span class="sc">*</span> delta),</span>
<span id="cb23-9"><a href="#cb23-9"></a>              <span class="dv">3</span>, <span class="at">byrow =</span> T)</span>
<span id="cb23-10"><a href="#cb23-10"></a></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="co"># containers</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>K <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">0</span><span class="sc">:</span>K_max, I <span class="sc">*</span> J, <span class="at">replace =</span> T), I, J)</span>
<span id="cb23-13"><a href="#cb23-13"></a>y <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(I, J, K_max))</span>
<span id="cb23-14"><a href="#cb23-14"></a></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="co"># simulation</span></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb23-17"><a href="#cb23-17"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>J) {</span>
<span id="cb23-18"><a href="#cb23-18"></a>    <span class="cf">if</span> (K[i, j]) {</span>
<span id="cb23-19"><a href="#cb23-19"></a>      y[i, j, <span class="dv">1</span><span class="sc">:</span>K[i, j]] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(K[i, j], P_y[z[i, j], ])</span>
<span id="cb23-20"><a href="#cb23-20"></a>    }</span>
<span id="cb23-21"><a href="#cb23-21"></a>  }</span>
<span id="cb23-22"><a href="#cb23-22"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="stan-program" class="level3">
<h3 class="anchored" data-anchor-id="stan-program">Stan program</h3>
<p>Below is the Stan program for the above model written with log probabilities. In many ways it is similar to the mark-recapture example, with the following noteworthy changes:</p>
<ul>
<li>When no surveys were done in a season (<code>K[i, j] = 0</code>), Stan will automatically skip over them because a loop <code>for (k in 1:0)</code> is ignored, unlike in R!</li>
<li>All entries in the <span class="math inline">\(3 \cdot J\)</span> matrix <code>Omega</code> are initialised with the observation process. For each secondary survey, I subset the appropriate column from <span class="math inline">\(P_y\)</span> and increment it onto <span class="math inline">\(\Omega_{:,j}\)</span>. The marginal likelihood of the observation process is just the sum of the respective log probabilities.</li>
<li>The continuous time transition rates <span class="math inline">\(\gamma\)</span>, <span class="math inline">\(\epsilon\)</span>, and <span class="math inline">\(\psi\)</span> are given Exponential(3) priors, as these are good priors when the snapshot property of HMMs is satisfied (see Equation 2 in <span class="citation" data-cites="goulet2021">(<a href="#ref-goulet2021" role="doc-biblioref">Goulet et al. 2021</a>)</span>).</li>
</ul>
<div class="cell" data-output.var="occ_dyn_ms">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">functions</span>{</span>
<span id="cb24-2"><a href="#cb24-2"></a>  <span class="co">// normalise a vector of log probabilities</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="dt">vector</span> normalise_log(<span class="dt">vector</span> A) {</span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="cf">return</span> A - log_sum_exp(A);</span>
<span id="cb24-5"><a href="#cb24-5"></a>  }</span>
<span id="cb24-6"><a href="#cb24-6"></a>  </span>
<span id="cb24-7"><a href="#cb24-7"></a>  <span class="co">/**</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="co">   * Return the natural logarithm of the product of the element-wise </span></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="co">   * exponentiation of the specified matrices</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="co">   *</span></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> A  First matrix or (row_)vector</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> B  Second matrix or (row_)vector</span></span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="co">   *</span></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="co">   * </span><span class="an">@return</span><span class="co">   log(exp(A) * exp(B))</span></span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="co">   */</span></span>
<span id="cb24-16"><a href="#cb24-16"></a>  <span class="dt">matrix</span> log_prod_exp(<span class="dt">matrix</span> A, <span class="dt">matrix</span> B) {</span>
<span id="cb24-17"><a href="#cb24-17"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb24-18"><a href="#cb24-18"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb24-19"><a href="#cb24-19"></a>    <span class="dt">int</span> K = cols(B);</span>
<span id="cb24-20"><a href="#cb24-20"></a>    <span class="dt">matrix</span>[J, I] A_tr = A';</span>
<span id="cb24-21"><a href="#cb24-21"></a>    <span class="dt">matrix</span>[I, K] C;</span>
<span id="cb24-22"><a href="#cb24-22"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb24-23"><a href="#cb24-23"></a>      <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb24-24"><a href="#cb24-24"></a>        C[i, k] = log_sum_exp(A_tr[:, i] + B[:, k]);</span>
<span id="cb24-25"><a href="#cb24-25"></a>      }</span>
<span id="cb24-26"><a href="#cb24-26"></a>    }</span>
<span id="cb24-27"><a href="#cb24-27"></a>    <span class="cf">return</span> C;</span>
<span id="cb24-28"><a href="#cb24-28"></a>  }</span>
<span id="cb24-29"><a href="#cb24-29"></a>  <span class="dt">vector</span> log_prod_exp(<span class="dt">matrix</span> A, <span class="dt">vector</span> B) {</span>
<span id="cb24-30"><a href="#cb24-30"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb24-31"><a href="#cb24-31"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb24-32"><a href="#cb24-32"></a>    <span class="dt">matrix</span>[J, I] A_tr = A';</span>
<span id="cb24-33"><a href="#cb24-33"></a>    <span class="dt">vector</span>[I] C;</span>
<span id="cb24-34"><a href="#cb24-34"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb24-35"><a href="#cb24-35"></a>      C[i] = log_sum_exp(A_tr[:, i] + B);</span>
<span id="cb24-36"><a href="#cb24-36"></a>    }</span>
<span id="cb24-37"><a href="#cb24-37"></a>    <span class="cf">return</span> C;</span>
<span id="cb24-38"><a href="#cb24-38"></a>  }</span>
<span id="cb24-39"><a href="#cb24-39"></a>  <span class="dt">row_vector</span> log_prod_exp(<span class="dt">row_vector</span> A, <span class="dt">matrix</span> B) {</span>
<span id="cb24-40"><a href="#cb24-40"></a>    <span class="dt">int</span> K = cols(B);</span>
<span id="cb24-41"><a href="#cb24-41"></a>    <span class="dt">vector</span>[size(A)] A_tr = A';</span>
<span id="cb24-42"><a href="#cb24-42"></a>    <span class="dt">row_vector</span>[K] C;</span>
<span id="cb24-43"><a href="#cb24-43"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb24-44"><a href="#cb24-44"></a>      C[k] = log_sum_exp(A_tr + B[:, k]);</span>
<span id="cb24-45"><a href="#cb24-45"></a>    }</span>
<span id="cb24-46"><a href="#cb24-46"></a>    <span class="cf">return</span> C;</span>
<span id="cb24-47"><a href="#cb24-47"></a>  }</span>
<span id="cb24-48"><a href="#cb24-48"></a>  <span class="dt">real</span> log_prod_exp(<span class="dt">row_vector</span> A, <span class="dt">vector</span> B) {</span>
<span id="cb24-49"><a href="#cb24-49"></a>    <span class="cf">return</span> log_sum_exp(A' + B);</span>
<span id="cb24-50"><a href="#cb24-50"></a>  }</span>
<span id="cb24-51"><a href="#cb24-51"></a>}</span>
<span id="cb24-52"><a href="#cb24-52"></a></span>
<span id="cb24-53"><a href="#cb24-53"></a><span class="kw">data</span> {</span>
<span id="cb24-54"><a href="#cb24-54"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I, J, K_max;</span>
<span id="cb24-55"><a href="#cb24-55"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=K_max&gt; K;</span>
<span id="cb24-56"><a href="#cb24-56"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt;[J - <span class="dv">1</span>] tau;</span>
<span id="cb24-57"><a href="#cb24-57"></a>  <span class="dt">array</span>[I, J, K_max] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=<span class="dv">3</span>&gt; y;</span>
<span id="cb24-58"><a href="#cb24-58"></a>}</span>
<span id="cb24-59"><a href="#cb24-59"></a></span>
<span id="cb24-60"><a href="#cb24-60"></a><span class="kw">parameters</span> {</span>
<span id="cb24-61"><a href="#cb24-61"></a>  <span class="dt">simplex</span>[<span class="dv">3</span>] eta;</span>
<span id="cb24-62"><a href="#cb24-62"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt;[<span class="dv">2</span>] gamma, epsilon, psi;</span>
<span id="cb24-63"><a href="#cb24-63"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[<span class="dv">2</span>] p;</span>
<span id="cb24-64"><a href="#cb24-64"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; delta;</span>
<span id="cb24-65"><a href="#cb24-65"></a>}</span>
<span id="cb24-66"><a href="#cb24-66"></a></span>
<span id="cb24-67"><a href="#cb24-67"></a><span class="kw">model</span> {</span>
<span id="cb24-68"><a href="#cb24-68"></a>  <span class="co">// priors</span></span>
<span id="cb24-69"><a href="#cb24-69"></a>  <span class="kw">target +=</span> dirichlet_lupdf(eta | ones_vector(<span class="dv">3</span>));</span>
<span id="cb24-70"><a href="#cb24-70"></a>  <span class="kw">target +=</span> exponential_lupdf(gamma | <span class="dv">3</span>);</span>
<span id="cb24-71"><a href="#cb24-71"></a>  <span class="kw">target +=</span> exponential_lupdf(epsilon | <span class="dv">3</span>);</span>
<span id="cb24-72"><a href="#cb24-72"></a>  <span class="kw">target +=</span> exponential_lupdf(psi | <span class="dv">3</span>);</span>
<span id="cb24-73"><a href="#cb24-73"></a>  <span class="kw">target +=</span> beta_lupdf(p | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb24-74"><a href="#cb24-74"></a>  <span class="kw">target +=</span> beta_lupdf(delta | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb24-75"><a href="#cb24-75"></a>  </span>
<span id="cb24-76"><a href="#cb24-76"></a>  <span class="co">// log initial state probabilities, TRM, and log TPMs</span></span>
<span id="cb24-77"><a href="#cb24-77"></a>  <span class="dt">vector</span>[<span class="dv">3</span>] log_eta = log(eta);</span>
<span id="cb24-78"><a href="#cb24-78"></a>  <span class="dt">matrix</span>[<span class="dv">3</span>, <span class="dv">3</span>] Q, P_y;</span>
<span id="cb24-79"><a href="#cb24-79"></a>  <span class="dt">array</span>[J - <span class="dv">1</span>] <span class="dt">matrix</span>[<span class="dv">3</span>, <span class="dv">3</span>] P_z;</span>
<span id="cb24-80"><a href="#cb24-80"></a>  Q = [[ -(gamma[<span class="dv">1</span>] + gamma[<span class="dv">2</span>]), gamma[<span class="dv">1</span>], gamma[<span class="dv">2</span>] ],</span>
<span id="cb24-81"><a href="#cb24-81"></a>       [ epsilon[<span class="dv">1</span>], -(epsilon[<span class="dv">1</span>] + psi[<span class="dv">1</span>]), psi[<span class="dv">1</span>] ],</span>
<span id="cb24-82"><a href="#cb24-82"></a>       [ epsilon[<span class="dv">2</span>], psi[<span class="dv">2</span>], -(epsilon[<span class="dv">2</span>] + psi[<span class="dv">2</span>]) ]];</span>
<span id="cb24-83"><a href="#cb24-83"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span>:J) {</span>
<span id="cb24-84"><a href="#cb24-84"></a>    P_z[j - <span class="dv">1</span>] = matrix_exp(Q * tau[j - <span class="dv">1</span>]);</span>
<span id="cb24-85"><a href="#cb24-85"></a>  }</span>
<span id="cb24-86"><a href="#cb24-86"></a>  P_z = log(P_z);</span>
<span id="cb24-87"><a href="#cb24-87"></a>  P_y = [[ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ],</span>
<span id="cb24-88"><a href="#cb24-88"></a>         [ <span class="dv">1</span> - p[<span class="dv">1</span>], p[<span class="dv">1</span>], <span class="dv">0</span> ],</span>
<span id="cb24-89"><a href="#cb24-89"></a>         [ <span class="dv">1</span> - p[<span class="dv">2</span>], p[<span class="dv">2</span>] * (<span class="dv">1</span> - delta), p[<span class="dv">2</span>] * delta ]];</span>
<span id="cb24-90"><a href="#cb24-90"></a>  P_y = log(P_y);</span>
<span id="cb24-91"><a href="#cb24-91"></a>  </span>
<span id="cb24-92"><a href="#cb24-92"></a>  <span class="co">// forward algorithm</span></span>
<span id="cb24-93"><a href="#cb24-93"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb24-94"><a href="#cb24-94"></a>    </span>
<span id="cb24-95"><a href="#cb24-95"></a>    <span class="co">// initialise marginal log probabilities with observation model</span></span>
<span id="cb24-96"><a href="#cb24-96"></a>    <span class="dt">matrix</span>[<span class="dv">3</span>, J] Omega = rep_matrix(<span class="dv">0</span>, <span class="dv">3</span>, J);</span>
<span id="cb24-97"><a href="#cb24-97"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span>:J) {</span>
<span id="cb24-98"><a href="#cb24-98"></a>      <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[i, j]) {</span>
<span id="cb24-99"><a href="#cb24-99"></a>        Omega[:, j] += P_y[:, y[i, j, k]];</span>
<span id="cb24-100"><a href="#cb24-100"></a>      }</span>
<span id="cb24-101"><a href="#cb24-101"></a>    }</span>
<span id="cb24-102"><a href="#cb24-102"></a>    </span>
<span id="cb24-103"><a href="#cb24-103"></a>    <span class="co">// increment ecological process</span></span>
<span id="cb24-104"><a href="#cb24-104"></a>    Omega[:, <span class="dv">1</span>] += log_eta;</span>
<span id="cb24-105"><a href="#cb24-105"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span>:J) {</span>
<span id="cb24-106"><a href="#cb24-106"></a>      Omega[:, j] += log_prod_exp(P_z[j - <span class="dv">1</span>]', Omega[:, j - <span class="dv">1</span>]);</span>
<span id="cb24-107"><a href="#cb24-107"></a>    }</span>
<span id="cb24-108"><a href="#cb24-108"></a>    </span>
<span id="cb24-109"><a href="#cb24-109"></a>    <span class="co">// increment log density</span></span>
<span id="cb24-110"><a href="#cb24-110"></a>    <span class="kw">target +=</span> log_sum_exp(Omega[:, J]);</span>
<span id="cb24-111"><a href="#cb24-111"></a>  }</span>
<span id="cb24-112"><a href="#cb24-112"></a>}</span>
<span id="cb24-113"><a href="#cb24-113"></a></span>
<span id="cb24-114"><a href="#cb24-114"></a><span class="kw">generated quantities</span> {</span>
<span id="cb24-115"><a href="#cb24-115"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb24-116"><a href="#cb24-116"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span> z;</span>
<span id="cb24-117"><a href="#cb24-117"></a>  {</span>
<span id="cb24-118"><a href="#cb24-118"></a>    <span class="dt">vector</span>[<span class="dv">3</span>] log_eta = log(eta);</span>
<span id="cb24-119"><a href="#cb24-119"></a>    <span class="dt">matrix</span>[<span class="dv">3</span>, <span class="dv">3</span>] Q, P_y;</span>
<span id="cb24-120"><a href="#cb24-120"></a>    <span class="dt">array</span>[J - <span class="dv">1</span>] <span class="dt">matrix</span>[<span class="dv">3</span>, <span class="dv">3</span>] P_z;</span>
<span id="cb24-121"><a href="#cb24-121"></a>    Q = [[ -(gamma[<span class="dv">1</span>] + gamma[<span class="dv">2</span>]), gamma[<span class="dv">1</span>], gamma[<span class="dv">2</span>] ],</span>
<span id="cb24-122"><a href="#cb24-122"></a>         [ epsilon[<span class="dv">1</span>], -(epsilon[<span class="dv">1</span>] + psi[<span class="dv">1</span>]), psi[<span class="dv">1</span>] ],</span>
<span id="cb24-123"><a href="#cb24-123"></a>         [ epsilon[<span class="dv">2</span>], psi[<span class="dv">2</span>], -(epsilon[<span class="dv">2</span>] + psi[<span class="dv">2</span>]) ]];</span>
<span id="cb24-124"><a href="#cb24-124"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span>:J) {</span>
<span id="cb24-125"><a href="#cb24-125"></a>      P_z[j - <span class="dv">1</span>] = matrix_exp(Q * tau[j - <span class="dv">1</span>]);</span>
<span id="cb24-126"><a href="#cb24-126"></a>    }</span>
<span id="cb24-127"><a href="#cb24-127"></a>    P_z = log(P_z);</span>
<span id="cb24-128"><a href="#cb24-128"></a>    P_y = [[ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ],</span>
<span id="cb24-129"><a href="#cb24-129"></a>           [ <span class="dv">1</span> - p[<span class="dv">1</span>], p[<span class="dv">1</span>], <span class="dv">0</span> ],</span>
<span id="cb24-130"><a href="#cb24-130"></a>           [ <span class="dv">1</span> - p[<span class="dv">2</span>], p[<span class="dv">2</span>] * (<span class="dv">1</span> - delta), p[<span class="dv">2</span>] * delta ]];</span>
<span id="cb24-131"><a href="#cb24-131"></a>    P_y = log(P_y);</span>
<span id="cb24-132"><a href="#cb24-132"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb24-133"><a href="#cb24-133"></a>      </span>
<span id="cb24-134"><a href="#cb24-134"></a>      <span class="co">// forward algorithm for log likelihood</span></span>
<span id="cb24-135"><a href="#cb24-135"></a>      <span class="dt">matrix</span>[<span class="dv">3</span>, J] Omega = rep_matrix(<span class="dv">0</span>, <span class="dv">3</span>, J);</span>
<span id="cb24-136"><a href="#cb24-136"></a>      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span>:J) {</span>
<span id="cb24-137"><a href="#cb24-137"></a>        <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[i, j]) {</span>
<span id="cb24-138"><a href="#cb24-138"></a>          Omega[:, j] += P_y[:, y[i, j, k]];</span>
<span id="cb24-139"><a href="#cb24-139"></a>        }</span>
<span id="cb24-140"><a href="#cb24-140"></a>      }</span>
<span id="cb24-141"><a href="#cb24-141"></a>      Omega[:, <span class="dv">1</span>] += log_eta;</span>
<span id="cb24-142"><a href="#cb24-142"></a>      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span>:J) {</span>
<span id="cb24-143"><a href="#cb24-143"></a>        Omega[:, j] += log_prod_exp(P_z[j - <span class="dv">1</span>]', Omega[:, j - <span class="dv">1</span>]);</span>
<span id="cb24-144"><a href="#cb24-144"></a>      }</span>
<span id="cb24-145"><a href="#cb24-145"></a>      log_lik[i] = log_sum_exp(Omega[:, J]);</span>
<span id="cb24-146"><a href="#cb24-146"></a>      </span>
<span id="cb24-147"><a href="#cb24-147"></a>      <span class="co">// backward algorithm for ecological states</span></span>
<span id="cb24-148"><a href="#cb24-148"></a>      z[i, J] = categorical_rng(exp(normalise_log(Omega[:, J])));</span>
<span id="cb24-149"><a href="#cb24-149"></a>      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">2</span>:J) {</span>
<span id="cb24-150"><a href="#cb24-150"></a>        <span class="dt">int</span> jj = J - j + <span class="dv">1</span>;  <span class="co">// reverse 1:(J - 1)</span></span>
<span id="cb24-151"><a href="#cb24-151"></a>        z[i, jj] = categorical_rng(exp(normalise_log(Omega[:, jj] </span>
<span id="cb24-152"><a href="#cb24-152"></a>                                                     + P_z[jj][:, z[i, jj + <span class="dv">1</span>]])));</span>
<span id="cb24-153"><a href="#cb24-153"></a>      }</span>
<span id="cb24-154"><a href="#cb24-154"></a>    }</span>
<span id="cb24-155"><a href="#cb24-155"></a>  }</span>
<span id="cb24-156"><a href="#cb24-156"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We’ll run Stan and visually summarise the parameter estimates, with the input plotted alongside in green. It looks like we did alright, but there is a lot of uncertainty, largely because sites can move between 3 states between each year. For this reason, dynamic occupancy models are notoriously data-hungry. Often the initial state parameters are particularly difficult to estimate and are sometimes best parameterised as the steady state vector of the TPM. I haven’t quite worked out how to implement this efficiently in Stan.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># data for Stan</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>occ_data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J =</span> J, <span class="at">K_max =</span> K_max, <span class="at">K =</span> K, <span class="at">tau =</span> tau, <span class="at">y =</span> y) <span class="sc">|&gt;</span> </span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="fu">sapply</span>(\(x) <span class="fu">replace</span>(x, <span class="fu">is.na</span>(x), <span class="dv">1</span>))</span>
<span id="cb25-4"><a href="#cb25-4"></a></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co"># run HMC</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>fit_dyn <span class="ot">&lt;-</span> occ_dyn_ms<span class="sc">$</span><span class="fu">sample</span>(<span class="at">data =</span> occ_data, <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> n_chains,</span>
<span id="cb25-7"><a href="#cb25-7"></a>                             <span class="at">iter_warmup =</span> n_iter, <span class="at">iter_sampling =</span> n_iter)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...

Chain 6 finished in 32.1 seconds.
Chain 8 finished in 32.8 seconds.
Chain 2 finished in 33.3 seconds.
Chain 5 finished in 34.8 seconds.
Chain 4 finished in 36.7 seconds.
Chain 7 finished in 37.3 seconds.
Chain 1 finished in 37.6 seconds.
Chain 3 finished in 44.2 seconds.

All 8 chains finished successfully.
Mean chain execution time: 36.1 seconds.
Total execution time: 44.4 seconds.</code></pre>
</div>
</div>
</section>
<section id="results" class="level3">
<h3 class="anchored" data-anchor-id="results">Results</h3>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>fit_dyn <span class="sc">|&gt;</span> </span>
<span id="cb27-2"><a href="#cb27-2"></a>  <span class="fu">gather_rvars</span>(eta[i], gamma[i], epsilon[i], psi[i], p[i], delta) <span class="sc">|&gt;</span> </span>
<span id="cb27-3"><a href="#cb27-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(eta, gamma, epsilon, psi, p, delta), </span>
<span id="cb27-4"><a href="#cb27-4"></a>         <span class="at">.variable =</span> <span class="fu">factor</span>(.variable, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"eta"</span>, <span class="st">"gamma"</span>, <span class="st">"epsilon"</span>, <span class="st">"psi"</span>, <span class="st">"p"</span>, <span class="st">"delta"</span>)),</span>
<span id="cb27-5"><a href="#cb27-5"></a>         <span class="at">process =</span> <span class="fu">if_else</span>(<span class="fu">str_detect</span>(.variable, <span class="fu">c</span>(<span class="st">"^p$|delta"</span>)), <span class="st">"Observation Process"</span>, <span class="st">"Ecological Process"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb27-6"><a href="#cb27-6"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">xdist =</span> .value, </span>
<span id="cb27-7"><a href="#cb27-7"></a>             <span class="at">y =</span> <span class="fu">if_else</span>(<span class="fu">is.na</span>(i), .variable, <span class="fu">str_c</span>(.variable, <span class="st">"["</span>, i, <span class="st">"]"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>               <span class="fu">fct_reorder</span>(<span class="fu">as.numeric</span>(.variable)) <span class="sc">|&gt;</span> </span>
<span id="cb27-9"><a href="#cb27-9"></a>               <span class="fu">fct_rev</span>())) <span class="sc">+</span> </span>
<span id="cb27-10"><a href="#cb27-10"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> process, <span class="at">scales =</span> <span class="st">"free_y"</span>, <span class="at">ncol =</span> <span class="dv">1</span>) <span class="sc">+</span> </span>
<span id="cb27-11"><a href="#cb27-11"></a>  <span class="fu">stat_pointinterval</span>(<span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>, <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="fl">0.1</span>)) <span class="sc">+</span></span>
<span id="cb27-12"><a href="#cb27-12"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(truth), <span class="at">colour =</span> green, <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="sc">-</span><span class="fl">0.1</span>)) <span class="sc">+</span></span>
<span id="cb27-13"><a href="#cb27-13"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks =</span> <span class="fu">seq</span>(<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="fl">0.2</span>), <span class="at">expand =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb27-14"><a href="#cb27-14"></a>  <span class="fu">scale_y_discrete</span>(<span class="at">labels =</span> ggplot2<span class="sc">:::</span>parse_safe) <span class="sc">+</span></span>
<span id="cb27-15"><a href="#cb27-15"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Posterior"</span>, <span class="at">y =</span> <span class="st">"Parameter"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="hmm-in-stan_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Let’s also check how many of our ecological ecological states were correctly recovered. Since only state 3 (snakes present and breeding) can be directly observed with certainty, we’ll only check the ecological states for those times where no breeding was observed.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>fit_dyn <span class="sc">|&gt;</span> </span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="fu">spread_rvars</span>(z[i, j]) <span class="sc">|&gt;</span> </span>
<span id="cb28-3"><a href="#cb28-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(.env<span class="sc">$</span>z),</span>
<span id="cb28-4"><a href="#cb28-4"></a>         <span class="at">max_y =</span> <span class="fu">apply</span>(y, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,  max, <span class="at">na.rm =</span> T) <span class="sc">|&gt;</span> <span class="fu">c</span>()) <span class="sc">|&gt;</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>  <span class="fu">filter</span>(<span class="fu">between</span>(max_y, <span class="dv">1</span>, <span class="dv">2</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb28-6"><a href="#cb28-6"></a>  <span class="fu">summarise</span>(<span class="at">prop_true =</span> <span class="fu">mean</span>(<span class="fu">median</span>(z) <span class="sc">==</span> truth))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 1
  prop_true
      &lt;dbl&gt;
1     0.643</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Steady state distribution
</div>
</div>
<div class="callout-body-container callout-body">
<p>ChatGPT tells me that to get the steady state distribution from a TPM, you perform the eigendecomposition of the TPM and the eigenvector corresponding to the eigenvalue of 1 is the steady state distribution. Stan does have eigendecomposition, so I’m sure there’s a way to parameterise the initial states nicely, but it gets more complicated with time- and/or individual-varying parameters.</p>
</div>
</div>
</section>
</section>
<section id="example-3-disease-structured-mark-recapture-with-state-misclassification" class="level2">
<h2 class="anchored" data-anchor-id="example-3-disease-structured-mark-recapture-with-state-misclassification">Example 3: Disease-structured mark-recapture with state misclassification</h2>
<p>The main reason I dove so deep into HMMs is because during my PhD I ran into a problem with my <a href="../portfolio/fleayi-adult.html">mark-recapture study on Fleay’s barred frogs</a> (<em>Mixophyes fleayi</em>). For two years I conducted mark-recapture surveys along Gondwana rainforest streams in northern New South Wales, Australia, swabbing every frog I found to test for the presence of the pathogenic amphibian chytrid fungus (<em>Batrachochytrium dendrobatidis</em>, <em>Bd</em>) <span class="citation" data-cites="scheele2019a">(<a href="#ref-scheele2019a" role="doc-biblioref">Scheele et al. 2019</a>)</span> to hopefully infer something about (1) the effect of <em>Bd</em> on frog mortality rates and (2) the infection dynamics.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/fleayi-hmm.jpg" class="img-fluid figure-img" style="width:78.6%"></p>
<figcaption>Adult male Fleay’s or silverblue-eyed barred frog (<em>Mixophyes fleayi</em>) from Border Ranges National Park, New South Wales, Australia.</figcaption>
</figure>
</div>
<p>The ecological TRM of such a disease-structured multistate model is pretty straightforward, with three possible states: (1) alive and uninfected, (2) alive and infected, and (3) dead, which is an absorbing state:</p>
<p><span id="eq-trm2"><span class="math display">\[
Q = \begin{bmatrix}
  -(\psi_1 + \phi_1) &amp; \psi_1 &amp; \phi_1 \\
  \psi_2 &amp; -(\psi_2 + \phi_2) &amp; \phi_2 \\
  0 &amp; 0 &amp; 0
\end{bmatrix}
\tag{10}\]</span></span></p>
<p>Here, <span class="math inline">\(\phi_{1:2}\)</span> are the mortality hazard rates of uninfected and infected frogs, respectively, and <span class="math inline">\(\psi_{1:2}\)</span> are the rates of gaining and clearing infections, respectively.</p>
<section id="nothing-is-certain" class="level3">
<h3 class="anchored" data-anchor-id="nothing-is-certain">Nothing is certain</h3>
<p>While I was running qPCRs in the lab on some swabs collected during high frequency surveys (1 week intervals) with large numbers of recaptures, I noticed some frogs were apparently frequently clearing and re-gaining infections. For instance, a frog captured on 5 successive weeks may have looked something like this: <span class="math inline">\(\left[ 2, 2, 1, 2, 1 \right]\)</span>, implying the infection was lost twice and gained once across 4 weeks. This seemed unlikely, and it struck me as more probable that I was simply getting false negatives. At the same time, I couldn’t rule out false positives, either, given that contamination is always a risk. The best way to account for this uncertainty is to model it.</p>
<p>I realised that if you conduct robust design sampling and collect a swab with each capture, you could essentially model the swabbing process like an occupancy model within a mark-recapture model. That is, imagine surveying frogs <span class="math inline">\(i \in 1:I\)</span> during <span class="math inline">\(j \in 1:J\)</span> primary occasions (say every 2 months). During each primary occasion, you conduct multiple secondary surveys <span class="math inline">\(k \in 1:K_j\)</span> within a short amount of time where you’re willing to assume the population is closed, that is, no animals dying, coming in, changing their infection state, etc. Every time you capture a frog, including those captured multiple times within a primary, you collect a swab. There are 3 possible observed states (<span class="math inline">\(o\)</span>) per secondary: (1) frog captured with swab <em>Bd</em>–, (2) frog captured with swab <em>Bd</em>+, and (3) frog not captured. The TPM of this observation process for repeat secondaries with false negatives and false positives is as follows, with ecological states in the rows and observed states in the columns:</p>
<p><span id="eq-P-o"><span class="math display">\[
P_o = \begin{bmatrix}
  p_1 \cdot ( 1 - \lambda_1) &amp; p_2 \cdot \lambda_1 &amp; 1 - p_1 \\
  p_2 \cdot (1 - \delta_1) &amp; p_2 \cdot \delta_1 &amp; 1 - p_2 \\
  0 &amp; 0 &amp; 1
\end{bmatrix}
\tag{11}\]</span></span> Where <span class="math inline">\(p_{1:2}\)</span> are the detection probabilities of uninfected and infected frogs, respectively, <span class="math inline">\(\lambda_1\)</span> is the probability of getting a <em>Bd</em>+ swab from an uninfected frog (false positive), and <span class="math inline">\(\delta_2\)</span> is the probability of detecting <em>Bd</em> on a swab from an infected frog (where <span class="math inline">\(1 - \delta_1\)</span> is the false negative probability). The <em>Bd</em> detection parameters <span class="math inline">\(\delta_1\)</span> and <span class="math inline">\(\lambda_1\)</span> are identified if at least some frogs are recaptured multiple times within a primary occasion.</p>
</section>
<section id="double-decking-the-hmm" class="level3">
<h3 class="anchored" data-anchor-id="double-decking-the-hmm">Double-decking the HMM</h3>
<p>This is already a lot, but it’s really no different from Example 2: a continuous time ecological process, simpler this time because the dead state is absorbing, and a discrete time observation process, albeit with an extra false positive parameter. However, the reality of the data was slightly more complex. It is conventional to run qPCR several times per swab to accurately quantify the DNA load present in a sample. But this is analogous to the swabbing process described above. Presumably, it’s possible to get false negatives and false positives in the qPCR diagnostic process as well. There are thus three diagnostic states (<span class="math inline">\(y\)</span>, data): (1) qPCR replicate <em>Bd</em>–, (2) qPCR replicate <em>Bd</em>+, or (3) no qPCR performed, because no frog was captured and thus no swab was collected. Typically, people will just average their measured DNA loads across runs and apply an inclusion criterion, such as that samples are considered infected when 2/3 qPCR replicates return <em>Bd</em> DNA. But we can do better by just modeling it. Here’s the TPM of the diagnostic process, with latent observed states in the rows and diagnostic states in the columns:</p>
<p><span id="eq-P-o"><span class="math display">\[
P_y = \begin{bmatrix}
  1 - \lambda_2 &amp; \lambda_2 &amp; 0 \\
  1 - \delta_2 &amp; \delta_2 &amp; 0 \\
  0 &amp; 0 &amp; 1
\end{bmatrix}
\tag{12}\]</span></span> where <span class="math inline">\(\lambda_2\)</span> is another false positive parameter and <span class="math inline">\(\delta_2\)</span> is the detection probability in the qPCR process.</p>
</section>
<section id="always-try-to-use-all-of-the-data" class="level3">
<h3 class="anchored" data-anchor-id="always-try-to-use-all-of-the-data">Always try to use all of the data</h3>
<p>Another element of this model involved incorporating infection intensity into the model. qPCR doesn’t just tell you whether a sample is infected, but it tells you how many DNA copies are present in the sample. So with infection intensities <span class="math inline">\(x\)</span> from multiple qPCR runs <span class="math inline">\(l \in 1:L\)</span> collected from multiple samples (<span class="math inline">\(n\)</span>), we can actually estimate the latent infection intensity on the individual <span class="math inline">\(m\)</span> and samples:</p>
<p><span id="eq-x"><span class="math display">\[
\begin{aligned}
  m_{i,j} &amp;\sim \mathrm{Lognormal} \left( \mu, \sigma_1 \right) \\
  n_{i,j,k} &amp;\sim \mathrm{Lognormal} \left( m_{i,j}, \sigma_2 \right) \\
  x_{i,j,k,l} &amp;\sim \mathrm{Lognormal} \left( n_{i,j,k}, \sigma_3 \right)
\end{aligned}
\tag{13}\]</span></span> where lognormals are used to ensure the infection intensities are positive, <span class="math inline">\(\mu\)</span> is the log population average and <span class="math inline">\(\sigma_{1:3}\)</span> are the population standard deviation and the errors of the swabbing and qPCR processes, respectively. One could of course model the individual infection intensities <span class="math inline">\(m_{ij}\)</span> more flexibly as individual-level time series, but my data was too sparse and probably way too noisy. We can now incorporate the infection intensities to the ecological and observation models by modeling <span class="math inline">\(\phi_2\)</span>, the mortality rates of infected frogs, and <span class="math inline">\(\delta_{1:2}\)</span>, the <em>Bd</em> detection probabilities, as functions of the relevant infection intensities, for example like this:</p>
<p><span id="eq-functions"><span class="math display">\[
\begin{aligned}
  {\phi_2}_{[i, j]} &amp;= \exp \left( \log {\phi_2}_\alpha + {\phi_2}_\beta \cdot m_{i,j} \right) \\
  {\delta_1}_{[i,j]} &amp;= 1 - (1 - r_1)^{m_{i,j}} \\
  {\delta_2}_{[i,j,k]} &amp;= 1 - (1 - r_2)^{n_{i,j,k}}
\end{aligned}
\tag{14}\]</span></span> Here, the first equation is a simple GLM of the mortality hazard rate as a function of time-varying individual infection intensity, and the <em>Bd</em> detection probabilities are modeled as a function of <span class="math inline">\(r_{1:2}\)</span>, or the probabilities of detecting one log gene copy of DNA on a swab or qPCR replicate.</p>
<p>Dr.&nbsp;Andy Royle and myself published this model in Methods in Ecology and Evolution where we initially implemented the model in NIMBLE <span class="citation" data-cites="hollanders2022c">(<a href="#ref-hollanders2022c" role="doc-biblioref">Hollanders and Royle 2022</a>)</span>. But of course, I was keen to try to marginalise out the latent ecological and observed states to fit this model in Stan (note that the ecological states are <em>completely</em> unobserved, as there’s no way of knowing whether an infected qPCR run actually came from an infected sample or frog!).</p>
</section>
<section id="simulation" class="level3">
<h3 class="anchored" data-anchor-id="simulation">Simulation</h3>
<p>Below I simulate some data where the rates of gaining and clearing infection are also affected by temperature (negative and positive, respectively), which seems to be the case for the frog-<em>Bd</em> system.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> To account for the varying infection dynamics in the state probabilities at first capture, I’ll use the steady state distribution for each primary which is computed using the infection dynamics <em>probabilities</em>, given by <span class="math inline">\({\psi_p}_{[1:2]} = 1 - \exp(-\psi_{1:2})\)</span>. Then, the expected probability of being infected at first capture in each primary is <span class="math inline">\(\eta = \frac{{\psi_p}_{[1]}}{{\psi_p}_{[1]} + {\psi_p}_{[2]}}\)</span>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="co"># metadata</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>I <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>J <span class="ot">&lt;-</span> <span class="dv">8</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>K_max <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>K <span class="ot">&lt;-</span> <span class="fu">rep</span>(K_max, J)</span>
<span id="cb30-6"><a href="#cb30-6"></a>L <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>tau <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(J <span class="sc">-</span> <span class="dv">1</span>, <span class="fu">log</span>(<span class="dv">1</span>), <span class="fl">0.5</span>)             <span class="co"># unequal primary occasion intervals</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>temp <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(J <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">|&gt;</span> <span class="fu">sort</span>(<span class="at">decreasing =</span> T)  <span class="co"># it's getting colder</span></span>
<span id="cb30-9"><a href="#cb30-9"></a></span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="co"># parameters</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>phi_a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.1</span>)       <span class="co"># mortality rates of uninfected/infected frogs (intercepts)</span></span>
<span id="cb30-12"><a href="#cb30-12"></a>phi_b <span class="ot">&lt;-</span> <span class="fl">0.3</span>               <span class="co"># effect of one log Bd gene copy on mortality</span></span>
<span id="cb30-13"><a href="#cb30-13"></a>psi_a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.7</span>, <span class="fl">0.4</span>)       <span class="co"># rates of gaining/clearing infections (intercepts)</span></span>
<span id="cb30-14"><a href="#cb30-14"></a>psi_b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.4</span>, <span class="fl">0.3</span>)      <span class="co"># effect of temperature on rates of gaining/clearing infections</span></span>
<span id="cb30-15"><a href="#cb30-15"></a>p_a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.7</span>, <span class="fl">0.6</span>)         <span class="co"># detection probabilities of uninfected/infected frogs</span></span>
<span id="cb30-16"><a href="#cb30-16"></a>r <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="fl">0.6</span>)           <span class="co"># pathogen detection probabilities (per log Bd gene copy)</span></span>
<span id="cb30-17"><a href="#cb30-17"></a>lambda <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.10</span>)    <span class="co"># sampling/diagnostic false positive probabilities</span></span>
<span id="cb30-18"><a href="#cb30-18"></a>mu <span class="ot">&lt;-</span> <span class="fl">1.0</span>                  <span class="co"># population log average infection intensity</span></span>
<span id="cb30-19"><a href="#cb30-19"></a>sigma <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.1</span>)  <span class="co"># population and sampling/diagnostic SDs</span></span>
<span id="cb30-20"><a href="#cb30-20"></a></span>
<span id="cb30-21"><a href="#cb30-21"></a><span class="co"># parameter containers</span></span>
<span id="cb30-22"><a href="#cb30-22"></a>phi <span class="ot">&lt;-</span> <span class="fu">matrix</span>(phi_a, <span class="dv">2</span>, J <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb30-23"><a href="#cb30-23"></a>psi <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">matrix</span>(<span class="fu">log</span>(psi_a), <span class="dv">2</span>, J <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">+</span> psi_b <span class="sc">%*%</span> <span class="fu">t</span>(temp))</span>
<span id="cb30-24"><a href="#cb30-24"></a>psi_p <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span>psi)</span>
<span id="cb30-25"><a href="#cb30-25"></a>eta <span class="ot">&lt;-</span> psi_p[<span class="dv">1</span>, ] <span class="sc">/</span> <span class="fu">colSums</span>(psi_p)</span>
<span id="cb30-26"><a href="#cb30-26"></a>p <span class="ot">&lt;-</span> <span class="fu">array</span>(p_a, <span class="fu">c</span>(<span class="dv">2</span>, J, K_max))</span>
<span id="cb30-27"><a href="#cb30-27"></a>delta1 <span class="ot">&lt;-</span> <span class="fu">numeric</span>(J)</span>
<span id="cb30-28"><a href="#cb30-28"></a>delta2 <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, J, K_max)</span>
<span id="cb30-29"><a href="#cb30-29"></a>m <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, I, J)</span>
<span id="cb30-30"><a href="#cb30-30"></a>n <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(I, J, K_max))</span>
<span id="cb30-31"><a href="#cb30-31"></a></span>
<span id="cb30-32"><a href="#cb30-32"></a><span class="co"># TPM containers</span></span>
<span id="cb30-33"><a href="#cb30-33"></a>Q <span class="ot">&lt;-</span> P_z <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, J <span class="sc">-</span> <span class="dv">1</span>))</span>
<span id="cb30-34"><a href="#cb30-34"></a>P_o <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, J, K_max))</span>
<span id="cb30-35"><a href="#cb30-35"></a>P_y <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, J, K_max))</span>
<span id="cb30-36"><a href="#cb30-36"></a></span>
<span id="cb30-37"><a href="#cb30-37"></a><span class="co"># primary occasions of first capture</span></span>
<span id="cb30-38"><a href="#cb30-38"></a>f <span class="ot">&lt;-</span> <span class="fu">sort</span>(<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>(J <span class="sc">-</span> <span class="dv">1</span>), I, <span class="at">replace =</span> T))</span>
<span id="cb30-39"><a href="#cb30-39"></a></span>
<span id="cb30-40"><a href="#cb30-40"></a><span class="co"># containers</span></span>
<span id="cb30-41"><a href="#cb30-41"></a>z <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, I, J)</span>
<span id="cb30-42"><a href="#cb30-42"></a>o <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(I, J, K_max))</span>
<span id="cb30-43"><a href="#cb30-43"></a>y <span class="ot">&lt;-</span> x <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(I, J, K_max, L))</span>
<span id="cb30-44"><a href="#cb30-44"></a></span>
<span id="cb30-45"><a href="#cb30-45"></a><span class="co"># simulate</span></span>
<span id="cb30-46"><a href="#cb30-46"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>I) {</span>
<span id="cb30-47"><a href="#cb30-47"></a>  </span>
<span id="cb30-48"><a href="#cb30-48"></a>  <span class="co"># fix detection probabilities in first secondary of first primary to ensure capture</span></span>
<span id="cb30-49"><a href="#cb30-49"></a>  p[, f[i], <span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb30-50"><a href="#cb30-50"></a>  </span>
<span id="cb30-51"><a href="#cb30-51"></a>  <span class="cf">for</span> (j <span class="cf">in</span> f[i]<span class="sc">:</span>J) {</span>
<span id="cb30-52"><a href="#cb30-52"></a>    </span>
<span id="cb30-53"><a href="#cb30-53"></a>    <span class="co"># infection intensities and pathogen detection probabilities</span></span>
<span id="cb30-54"><a href="#cb30-54"></a>    m[i, j] <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(<span class="dv">1</span>, mu, sigma[<span class="dv">1</span>])</span>
<span id="cb30-55"><a href="#cb30-55"></a>    delta1[j] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> (<span class="dv">1</span> <span class="sc">-</span> r[<span class="dv">1</span>])<span class="sc">^</span>m[i, j]</span>
<span id="cb30-56"><a href="#cb30-56"></a>    n[i, j, <span class="dv">1</span><span class="sc">:</span>K[j]] <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(K[j], <span class="fu">log</span>(m[i, j]), sigma[<span class="dv">2</span>])</span>
<span id="cb30-57"><a href="#cb30-57"></a>    delta2[j, <span class="dv">1</span><span class="sc">:</span>K[j]] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> (<span class="dv">1</span> <span class="sc">-</span> r[<span class="dv">2</span>])<span class="sc">^</span>n[i, j, <span class="dv">1</span><span class="sc">:</span>K[j]]</span>
<span id="cb30-58"><a href="#cb30-58"></a>    </span>
<span id="cb30-59"><a href="#cb30-59"></a>    <span class="co"># observation and diagnostic TPMs</span></span>
<span id="cb30-60"><a href="#cb30-60"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K[j]) {</span>
<span id="cb30-61"><a href="#cb30-61"></a>      P_o[, , j, k] <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(p[<span class="dv">1</span>, j, k] <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> lambda[<span class="dv">1</span>]), p[<span class="dv">1</span>, j, k] <span class="sc">*</span> lambda[<span class="dv">1</span>], <span class="dv">1</span> <span class="sc">-</span> p[<span class="dv">1</span>, j, k],</span>
<span id="cb30-62"><a href="#cb30-62"></a>                                p[<span class="dv">2</span>, j, k] <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> delta1[j]), p[<span class="dv">2</span>, j, k] <span class="sc">*</span> delta1[j], <span class="dv">1</span> <span class="sc">-</span> p[<span class="dv">2</span>, j, k], </span>
<span id="cb30-63"><a href="#cb30-63"></a>                                <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>), </span>
<span id="cb30-64"><a href="#cb30-64"></a>                              <span class="dv">3</span>, <span class="at">byrow =</span> T)</span>
<span id="cb30-65"><a href="#cb30-65"></a>      P_y[, , j, k] <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span> <span class="sc">-</span> lambda[<span class="dv">2</span>], lambda[<span class="dv">2</span>], <span class="dv">0</span>, </span>
<span id="cb30-66"><a href="#cb30-66"></a>                                <span class="dv">1</span> <span class="sc">-</span> delta2[j, k], delta2[j, k], <span class="dv">0</span>, </span>
<span id="cb30-67"><a href="#cb30-67"></a>                                <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>), </span>
<span id="cb30-68"><a href="#cb30-68"></a>                              <span class="dv">3</span>, <span class="at">byrow =</span> T)</span>
<span id="cb30-69"><a href="#cb30-69"></a>    }</span>
<span id="cb30-70"><a href="#cb30-70"></a>  }</span>
<span id="cb30-71"><a href="#cb30-71"></a>  </span>
<span id="cb30-72"><a href="#cb30-72"></a>  <span class="co"># mortality rates and ecological TRM/TPMs</span></span>
<span id="cb30-73"><a href="#cb30-73"></a>  <span class="cf">for</span> (j <span class="cf">in</span> f[i]<span class="sc">:</span>(J <span class="sc">-</span> <span class="dv">1</span>)) {</span>
<span id="cb30-74"><a href="#cb30-74"></a>    phi[<span class="dv">2</span>, j] <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">log</span>(phi_a[<span class="dv">2</span>]) <span class="sc">+</span> phi_b <span class="sc">*</span> m[i, j])</span>
<span id="cb30-75"><a href="#cb30-75"></a>    Q[, , j] <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="sc">-</span>(psi[<span class="dv">1</span>, j] <span class="sc">+</span> phi[<span class="dv">1</span>, j]), psi[<span class="dv">1</span>, j], phi[<span class="dv">1</span>, j], </span>
<span id="cb30-76"><a href="#cb30-76"></a>                         psi[<span class="dv">2</span>, j], <span class="sc">-</span>(psi[<span class="dv">2</span>, j] <span class="sc">+</span> phi[<span class="dv">2</span>, j]), phi[<span class="dv">2</span>, j], </span>
<span id="cb30-77"><a href="#cb30-77"></a>                         <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), </span>
<span id="cb30-78"><a href="#cb30-78"></a>                       <span class="dv">3</span>, <span class="at">byrow =</span> T)</span>
<span id="cb30-79"><a href="#cb30-79"></a>    P_z[, , j] <span class="ot">&lt;-</span> <span class="fu">expm</span>(Q[, , j] <span class="sc">*</span> tau[j])</span>
<span id="cb30-80"><a href="#cb30-80"></a>  }</span>
<span id="cb30-81"><a href="#cb30-81"></a>  </span>
<span id="cb30-82"><a href="#cb30-82"></a>  <span class="co"># ecological process</span></span>
<span id="cb30-83"><a href="#cb30-83"></a>  z[i, f[i]] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">1</span> <span class="sc">-</span> eta[f[i]], eta[f[i]]))</span>
<span id="cb30-84"><a href="#cb30-84"></a>  <span class="cf">for</span> (j <span class="cf">in</span> (f[i] <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span>J) {</span>
<span id="cb30-85"><a href="#cb30-85"></a>    z[i, j] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">1</span>, P_z[z[i, j <span class="sc">-</span> <span class="dv">1</span>], , j <span class="sc">-</span> <span class="dv">1</span>])</span>
<span id="cb30-86"><a href="#cb30-86"></a>  }</span>
<span id="cb30-87"><a href="#cb30-87"></a>  </span>
<span id="cb30-88"><a href="#cb30-88"></a>  <span class="co"># observation and diagnostic process</span></span>
<span id="cb30-89"><a href="#cb30-89"></a>  <span class="cf">for</span> (j <span class="cf">in</span> f[i]<span class="sc">:</span>J) {</span>
<span id="cb30-90"><a href="#cb30-90"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K[j]) {</span>
<span id="cb30-91"><a href="#cb30-91"></a>      o[i, j, k] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">1</span>, P_o[z[i, j], , j, k])</span>
<span id="cb30-92"><a href="#cb30-92"></a>      y[i, j, k, ] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(L, P_y[o[i, j, k], , j, k])</span>
<span id="cb30-93"><a href="#cb30-93"></a>      </span>
<span id="cb30-94"><a href="#cb30-94"></a>      <span class="co"># diagnostic run infection intensity</span></span>
<span id="cb30-95"><a href="#cb30-95"></a>      <span class="cf">for</span> (l <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>L) {</span>
<span id="cb30-96"><a href="#cb30-96"></a>        <span class="cf">if</span> (y[i, j, k, l] <span class="sc">==</span> <span class="dv">2</span>) {</span>
<span id="cb30-97"><a href="#cb30-97"></a>          x[i, j, k, l] <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(<span class="dv">1</span>, <span class="fu">log</span>(n[i, j, k]), sigma[<span class="dv">3</span>])</span>
<span id="cb30-98"><a href="#cb30-98"></a>        }</span>
<span id="cb30-99"><a href="#cb30-99"></a>      }</span>
<span id="cb30-100"><a href="#cb30-100"></a>    }</span>
<span id="cb30-101"><a href="#cb30-101"></a>  }</span>
<span id="cb30-102"><a href="#cb30-102"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="stan-implementation" class="level3">
<h3 class="anchored" data-anchor-id="stan-implementation">Stan implementation</h3>
<p>This model took me a lot of time to get going in Stan, but I got there in the end. I won’t go into detail about explaining everything, but I’ll mention a few key things here:</p>
<ul>
<li>We only need to account for the pathogen detection components between an individual’s first and last primary of capture, because no samples are collected when an individual isn’t captured. This means <span class="math inline">\(P_o\)</span> and <span class="math inline">\(P_y\)</span> can be constructed as <span class="math inline">\(2 \cdot 2\)</span> matrices corresponding to the two alive states. Since this model doesn’t include any variation on detection, I created a vector <code>lp_not_detected</code> which holds the marginal log probabilities of not being detected for all three states, which is just <span class="math inline">\(\log\left([1 - p_1, 1 - p_2, 1\right]^\intercal)\)</span>.</li>
<li>Robust design sampling means we can actually model the detection probabilities of the first primary. We do have to fix the first secondary that the individual was caught to 1, but are free to estimate the remaining detection probabilities.</li>
<li>The marginal log probabilities <code>Omega</code> are initialised with the observation and diagnostic TPMs for each secondary. This involves a sort of intermediate forward algorithm, where I (log) matrix multiply the observation TPM with the marginal log probabilities of the diagnostic outcomes (summing the log probabilities of each diagnostic run for each state, for which I created a <code>row_sums()</code> function).</li>
<li>The inclusion of false positives means the observation and diagnostic processes are examples of finite mixtures that may have multimodality in certain model constructions <span class="citation" data-cites="royle2006">(<a href="#ref-royle2006" role="doc-biblioref">Royle and Link 2006</a>)</span>. Here, the true pathogen detection probabilities <span class="math inline">\(\delta\)</span> are modeled as a function of infection intensity, which <em>may</em> be enough to avoid the multimodality. Just to be sure, however, I’ve constrained <span class="math inline">\(\lambda_{1:2}\)</span> to be less than <span class="math inline">\(r_{1:2}\)</span> in the program and further supplied <span class="math inline">\(\mathrm{Beta} (1, 10)\)</span> priors for <span class="math inline">\(\lambda\)</span>.</li>
<li>The individual infection intensities <code>m[i, j]</code> are parameterised as centered lognormal and the sample infection intensities <code>n[i, j, k]</code> as non-centered lognormal, as this seemed to give the best HMC performance.</li>
</ul>
<div class="cell" data-output.var="multievent">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource stan number-lines code-with-copy"><code class="sourceCode stan"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">functions</span> {</span>
<span id="cb31-2"><a href="#cb31-2"></a>  <span class="co">// normalise a vector of log probabilities</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>  <span class="dt">vector</span> normalise_log(<span class="dt">vector</span> A) {</span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="cf">return</span> A - log_sum_exp(A);</span>
<span id="cb31-5"><a href="#cb31-5"></a>  }</span>
<span id="cb31-6"><a href="#cb31-6"></a>  </span>
<span id="cb31-7"><a href="#cb31-7"></a>  <span class="co">/**</span></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="co">   * Return the natural logarithm of the product of the element-wise </span></span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="co">   * exponentiation of the specified matrices</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="co">   *</span></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> A  First matrix or (row_)vector</span></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> B  Second matrix or (row_)vector</span></span>
<span id="cb31-13"><a href="#cb31-13"></a><span class="co">   *</span></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="co">   * </span><span class="an">@return</span><span class="co">   log(exp(A) * exp(B))</span></span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="co">   */</span></span>
<span id="cb31-16"><a href="#cb31-16"></a>  <span class="dt">matrix</span> log_prod_exp(<span class="dt">matrix</span> A, <span class="dt">matrix</span> B) {</span>
<span id="cb31-17"><a href="#cb31-17"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb31-18"><a href="#cb31-18"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb31-19"><a href="#cb31-19"></a>    <span class="dt">int</span> K = cols(B);</span>
<span id="cb31-20"><a href="#cb31-20"></a>    <span class="dt">matrix</span>[J, I] A_tr = A';</span>
<span id="cb31-21"><a href="#cb31-21"></a>    <span class="dt">matrix</span>[I, K] C;</span>
<span id="cb31-22"><a href="#cb31-22"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb31-23"><a href="#cb31-23"></a>      <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-24"><a href="#cb31-24"></a>        C[i, k] = log_sum_exp(A_tr[:, i] + B[:, k]);</span>
<span id="cb31-25"><a href="#cb31-25"></a>      }</span>
<span id="cb31-26"><a href="#cb31-26"></a>    }</span>
<span id="cb31-27"><a href="#cb31-27"></a>    <span class="cf">return</span> C;</span>
<span id="cb31-28"><a href="#cb31-28"></a>  }</span>
<span id="cb31-29"><a href="#cb31-29"></a>  <span class="dt">vector</span> log_prod_exp(<span class="dt">matrix</span> A, <span class="dt">vector</span> B) {</span>
<span id="cb31-30"><a href="#cb31-30"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb31-31"><a href="#cb31-31"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb31-32"><a href="#cb31-32"></a>    <span class="dt">matrix</span>[J, I] A_tr = A';</span>
<span id="cb31-33"><a href="#cb31-33"></a>    <span class="dt">vector</span>[I] C;</span>
<span id="cb31-34"><a href="#cb31-34"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-35"><a href="#cb31-35"></a>      C[i] = log_sum_exp(A_tr[:, i] + B);</span>
<span id="cb31-36"><a href="#cb31-36"></a>    }</span>
<span id="cb31-37"><a href="#cb31-37"></a>    <span class="cf">return</span> C;</span>
<span id="cb31-38"><a href="#cb31-38"></a>  }</span>
<span id="cb31-39"><a href="#cb31-39"></a>  <span class="dt">row_vector</span> log_prod_exp(<span class="dt">row_vector</span> A, <span class="dt">matrix</span> B) {</span>
<span id="cb31-40"><a href="#cb31-40"></a>    <span class="dt">int</span> K = cols(B);</span>
<span id="cb31-41"><a href="#cb31-41"></a>    <span class="dt">vector</span>[size(A)] A_tr = A';</span>
<span id="cb31-42"><a href="#cb31-42"></a>    <span class="dt">row_vector</span>[K] C;</span>
<span id="cb31-43"><a href="#cb31-43"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K) {</span>
<span id="cb31-44"><a href="#cb31-44"></a>      C[k] = log_sum_exp(A_tr + B[:, k]);</span>
<span id="cb31-45"><a href="#cb31-45"></a>    }</span>
<span id="cb31-46"><a href="#cb31-46"></a>    <span class="cf">return</span> C;</span>
<span id="cb31-47"><a href="#cb31-47"></a>  }</span>
<span id="cb31-48"><a href="#cb31-48"></a>  <span class="dt">real</span> log_prod_exp(<span class="dt">row_vector</span> A, <span class="dt">vector</span> B) {</span>
<span id="cb31-49"><a href="#cb31-49"></a>    <span class="cf">return</span> log_sum_exp(A' + B);</span>
<span id="cb31-50"><a href="#cb31-50"></a>  }</span>
<span id="cb31-51"><a href="#cb31-51"></a>  </span>
<span id="cb31-52"><a href="#cb31-52"></a>  <span class="co">/**</span></span>
<span id="cb31-53"><a href="#cb31-53"></a><span class="co">   * Row- or column sums of a matrix</span></span>
<span id="cb31-54"><a href="#cb31-54"></a><span class="co">   *</span></span>
<span id="cb31-55"><a href="#cb31-55"></a><span class="co">   * </span><span class="an">@param</span><span class="co"> A  Matrix</span></span>
<span id="cb31-56"><a href="#cb31-56"></a><span class="co">   *</span></span>
<span id="cb31-57"><a href="#cb31-57"></a><span class="co">   * </span><span class="an">@return</span><span class="co">   (Row-)vector with the sums of each row or column</span></span>
<span id="cb31-58"><a href="#cb31-58"></a><span class="co">   */</span></span>
<span id="cb31-59"><a href="#cb31-59"></a>  <span class="dt">vector</span> row_sums(<span class="dt">matrix</span> A) {</span>
<span id="cb31-60"><a href="#cb31-60"></a>    <span class="dt">int</span> I = rows(A);</span>
<span id="cb31-61"><a href="#cb31-61"></a>    <span class="dt">vector</span>[I] B;</span>
<span id="cb31-62"><a href="#cb31-62"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-63"><a href="#cb31-63"></a>      B[i] = sum(A[i]);</span>
<span id="cb31-64"><a href="#cb31-64"></a>    }</span>
<span id="cb31-65"><a href="#cb31-65"></a>    <span class="cf">return</span> B;</span>
<span id="cb31-66"><a href="#cb31-66"></a>  }</span>
<span id="cb31-67"><a href="#cb31-67"></a>  <span class="dt">row_vector</span> col_sums(<span class="dt">matrix</span> A) {</span>
<span id="cb31-68"><a href="#cb31-68"></a>    <span class="dt">int</span> J = cols(A);</span>
<span id="cb31-69"><a href="#cb31-69"></a>    <span class="dt">row_vector</span>[J] B;</span>
<span id="cb31-70"><a href="#cb31-70"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span>:J) {</span>
<span id="cb31-71"><a href="#cb31-71"></a>      B[j] = sum(A[:, j]);</span>
<span id="cb31-72"><a href="#cb31-72"></a>    }</span>
<span id="cb31-73"><a href="#cb31-73"></a>    <span class="cf">return</span> B;</span>
<span id="cb31-74"><a href="#cb31-74"></a>  }</span>
<span id="cb31-75"><a href="#cb31-75"></a>}</span>
<span id="cb31-76"><a href="#cb31-76"></a></span>
<span id="cb31-77"><a href="#cb31-77"></a><span class="kw">data</span> {</span>
<span id="cb31-78"><a href="#cb31-78"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; I, J, K_max, L, S;</span>
<span id="cb31-79"><a href="#cb31-79"></a>  <span class="dt">array</span>[J] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=K_max&gt; K;</span>
<span id="cb31-80"><a href="#cb31-80"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=J&gt; f; </span>
<span id="cb31-81"><a href="#cb31-81"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=f, <span class="kw">upper</span>=J&gt; l; </span>
<span id="cb31-82"><a href="#cb31-82"></a>  <span class="dt">array</span>[I] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=K_max&gt; f_k;</span>
<span id="cb31-83"><a href="#cb31-83"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt;[J - <span class="dv">1</span>] tau;</span>
<span id="cb31-84"><a href="#cb31-84"></a>  <span class="dt">row_vector</span>[J - <span class="dv">1</span>] temp;</span>
<span id="cb31-85"><a href="#cb31-85"></a>  <span class="dt">array</span>[I, J, K_max, L] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>, <span class="kw">upper</span>=<span class="dv">3</span>&gt; y;</span>
<span id="cb31-86"><a href="#cb31-86"></a>  <span class="dt">array</span>[S] <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; ind, prim, sec;</span>
<span id="cb31-87"><a href="#cb31-87"></a>  <span class="dt">vector</span>[S] x;</span>
<span id="cb31-88"><a href="#cb31-88"></a>}</span>
<span id="cb31-89"><a href="#cb31-89"></a></span>
<span id="cb31-90"><a href="#cb31-90"></a><span class="kw">transformed data</span> {</span>
<span id="cb31-91"><a href="#cb31-91"></a>  <span class="dt">array</span>[I, J, K_max] <span class="dt">int</span> q;  <span class="co">// detected during secondary</span></span>
<span id="cb31-92"><a href="#cb31-92"></a>  <span class="dt">int</span> M = <span class="dv">0</span>, N = <span class="dv">0</span>;  <span class="co">// number of parameters for individual and sample loads</span></span>
<span id="cb31-93"><a href="#cb31-93"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-94"><a href="#cb31-94"></a>    <span class="cf">for</span> (j <span class="cf">in</span> f[i]:J) {</span>
<span id="cb31-95"><a href="#cb31-95"></a>      M += <span class="dv">1</span>;</span>
<span id="cb31-96"><a href="#cb31-96"></a>      <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-97"><a href="#cb31-97"></a>        q[i, j, k] = min(y[i, j, k]) &lt; <span class="dv">3</span>;</span>
<span id="cb31-98"><a href="#cb31-98"></a>        N += <span class="dv">1</span>;</span>
<span id="cb31-99"><a href="#cb31-99"></a>      }</span>
<span id="cb31-100"><a href="#cb31-100"></a>    }</span>
<span id="cb31-101"><a href="#cb31-101"></a>  }</span>
<span id="cb31-102"><a href="#cb31-102"></a>}</span>
<span id="cb31-103"><a href="#cb31-103"></a></span>
<span id="cb31-104"><a href="#cb31-104"></a><span class="kw">parameters</span> {</span>
<span id="cb31-105"><a href="#cb31-105"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt;[<span class="dv">2</span>] phi_a, psi_a;</span>
<span id="cb31-106"><a href="#cb31-106"></a>  <span class="dt">real</span> phi_b;</span>
<span id="cb31-107"><a href="#cb31-107"></a>  <span class="dt">vector</span>[<span class="dv">2</span>] psi_b;</span>
<span id="cb31-108"><a href="#cb31-108"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt;[<span class="dv">2</span>] p_a, r;</span>
<span id="cb31-109"><a href="#cb31-109"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=r&gt;[<span class="dv">2</span>] lambda;</span>
<span id="cb31-110"><a href="#cb31-110"></a>  <span class="dt">real</span> mu;</span>
<span id="cb31-111"><a href="#cb31-111"></a>  <span class="dt">vector</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt;[<span class="dv">3</span>] sigma;   </span>
<span id="cb31-112"><a href="#cb31-112"></a>  <span class="dt">vector</span>[M] log_m;</span>
<span id="cb31-113"><a href="#cb31-113"></a>  <span class="dt">vector</span>[N] log_n_z;         </span>
<span id="cb31-114"><a href="#cb31-114"></a>}</span>
<span id="cb31-115"><a href="#cb31-115"></a></span>
<span id="cb31-116"><a href="#cb31-116"></a><span class="kw">model</span> {</span>
<span id="cb31-117"><a href="#cb31-117"></a>  <span class="co">// priors</span></span>
<span id="cb31-118"><a href="#cb31-118"></a>  <span class="kw">target +=</span> exponential_lupdf(phi_a | <span class="dv">1</span>);</span>
<span id="cb31-119"><a href="#cb31-119"></a>  <span class="kw">target +=</span> std_normal_lupdf(phi_b);</span>
<span id="cb31-120"><a href="#cb31-120"></a>  <span class="kw">target +=</span> exponential_lupdf(psi_a | <span class="dv">1</span>);</span>
<span id="cb31-121"><a href="#cb31-121"></a>  <span class="kw">target +=</span> std_normal_lupdf(psi_b);</span>
<span id="cb31-122"><a href="#cb31-122"></a>  <span class="kw">target +=</span> beta_lupdf(p_a | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb31-123"><a href="#cb31-123"></a>  <span class="kw">target +=</span> beta_lupdf(r | <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb31-124"><a href="#cb31-124"></a>  <span class="kw">target +=</span> beta_lupdf(lambda | <span class="dv">1</span>, <span class="dv">10</span>);</span>
<span id="cb31-125"><a href="#cb31-125"></a>  <span class="kw">target +=</span> normal_lupdf(mu | <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb31-126"><a href="#cb31-126"></a>  <span class="kw">target +=</span> exponential_lupdf(sigma | <span class="dv">1</span>);</span>
<span id="cb31-127"><a href="#cb31-127"></a>  <span class="kw">target +=</span> normal_lupdf(log_m | mu, sigma[<span class="dv">1</span>]);</span>
<span id="cb31-128"><a href="#cb31-128"></a>  <span class="kw">target +=</span> std_normal_lupdf(log_n_z);</span>
<span id="cb31-129"><a href="#cb31-129"></a>  </span>
<span id="cb31-130"><a href="#cb31-130"></a>  <span class="co">// fill in individual and sample infection containers</span></span>
<span id="cb31-131"><a href="#cb31-131"></a>  <span class="dt">matrix</span>[I, J] m;</span>
<span id="cb31-132"><a href="#cb31-132"></a>  <span class="dt">array</span>[I] <span class="dt">matrix</span>[J, K_max] n;</span>
<span id="cb31-133"><a href="#cb31-133"></a>  <span class="dt">int</span> m_idx = <span class="dv">1</span>, n_idx = <span class="dv">1</span>;</span>
<span id="cb31-134"><a href="#cb31-134"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-135"><a href="#cb31-135"></a>    <span class="cf">for</span> (j <span class="cf">in</span> f[i]:J) {</span>
<span id="cb31-136"><a href="#cb31-136"></a>      m[i, j] = log_m[m_idx];</span>
<span id="cb31-137"><a href="#cb31-137"></a>      m_idx += <span class="dv">1</span>;</span>
<span id="cb31-138"><a href="#cb31-138"></a>      <span class="cf">if</span> (j &lt;= l[i]) {</span>
<span id="cb31-139"><a href="#cb31-139"></a>        <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-140"><a href="#cb31-140"></a>          n[i][j, k] = m[i, j] + log_n_z[n_idx] * sigma[<span class="dv">2</span>];</span>
<span id="cb31-141"><a href="#cb31-141"></a>          n_idx += <span class="dv">1</span>;</span>
<span id="cb31-142"><a href="#cb31-142"></a>        }</span>
<span id="cb31-143"><a href="#cb31-143"></a>      }</span>
<span id="cb31-144"><a href="#cb31-144"></a>    }</span>
<span id="cb31-145"><a href="#cb31-145"></a>  }</span>
<span id="cb31-146"><a href="#cb31-146"></a>  </span>
<span id="cb31-147"><a href="#cb31-147"></a>  <span class="co">// likelihood of diagnostic infection intensities</span></span>
<span id="cb31-148"><a href="#cb31-148"></a>  <span class="cf">for</span> (s <span class="cf">in</span> <span class="dv">1</span>:S) {</span>
<span id="cb31-149"><a href="#cb31-149"></a>    <span class="kw">target +=</span> lognormal_lupdf(x[s] | n[ind[s]][prim[s], sec[s]], sigma[<span class="dv">3</span>]);</span>
<span id="cb31-150"><a href="#cb31-150"></a>  }</span>
<span id="cb31-151"><a href="#cb31-151"></a>  </span>
<span id="cb31-152"><a href="#cb31-152"></a>  <span class="co">// exponentiate log infection intensities</span></span>
<span id="cb31-153"><a href="#cb31-153"></a>  m = exp(m);</span>
<span id="cb31-154"><a href="#cb31-154"></a>  n = exp(n);</span>
<span id="cb31-155"><a href="#cb31-155"></a>  </span>
<span id="cb31-156"><a href="#cb31-156"></a>  <span class="co">// ecological rates and initial state log probabilities</span></span>
<span id="cb31-157"><a href="#cb31-157"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, J - <span class="dv">1</span>] phi = rep_matrix(phi_a, J - <span class="dv">1</span>);</span>
<span id="cb31-158"><a href="#cb31-158"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, J - <span class="dv">1</span>] psi = exp(rep_matrix(log(psi_a), J - <span class="dv">1</span>) + psi_b * temp);</span>
<span id="cb31-159"><a href="#cb31-159"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, J - <span class="dv">1</span>] psi_p = <span class="dv">1</span> - exp(-psi);</span>
<span id="cb31-160"><a href="#cb31-160"></a>  <span class="dt">row_vector</span>[J - <span class="dv">1</span>] eta = psi_p[<span class="dv">1</span>] ./ col_sums(psi_p);</span>
<span id="cb31-161"><a href="#cb31-161"></a>  <span class="dt">row_vector</span>[J - <span class="dv">1</span>] log_eta = log(eta), log1m_eta = log1m(eta);</span>
<span id="cb31-162"><a href="#cb31-162"></a>  </span>
<span id="cb31-163"><a href="#cb31-163"></a>  <span class="co">// containers</span></span>
<span id="cb31-164"><a href="#cb31-164"></a>  <span class="dt">vector</span>[<span class="dv">3</span>] lp_not_detected = append_row(log1m(p_a), <span class="dv">0</span>);  <span class="co">// undetected vector</span></span>
<span id="cb31-165"><a href="#cb31-165"></a>  <span class="dt">tuple</span>(<span class="dt">row_vector</span>[J], <span class="dt">matrix</span>[J, K_max]) delta;</span>
<span id="cb31-166"><a href="#cb31-166"></a>  <span class="dt">array</span>[J - <span class="dv">1</span>] <span class="dt">matrix</span>[<span class="dv">3</span>, <span class="dv">3</span>] Q, P_z;</span>
<span id="cb31-167"><a href="#cb31-167"></a>  <span class="dt">matrix</span>[<span class="dv">2</span>, <span class="dv">2</span>] P_o, P_y;</span>
<span id="cb31-168"><a href="#cb31-168"></a>  <span class="dt">matrix</span>[<span class="dv">3</span>, J] Omega;</span>
<span id="cb31-169"><a href="#cb31-169"></a>  </span>
<span id="cb31-170"><a href="#cb31-170"></a>  <span class="co">// for each individual</span></span>
<span id="cb31-171"><a href="#cb31-171"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-172"><a href="#cb31-172"></a>    </span>
<span id="cb31-173"><a href="#cb31-173"></a>    <span class="co">// overwite mortality rates of infected</span></span>
<span id="cb31-174"><a href="#cb31-174"></a>    phi[<span class="dv">2</span>][f[i]:(J - <span class="dv">1</span>)] = exp(log(phi_a[<span class="dv">2</span>]) + phi_b * m[i, f[i]:(J - <span class="dv">1</span>)]);</span>
<span id="cb31-175"><a href="#cb31-175"></a>    </span>
<span id="cb31-176"><a href="#cb31-176"></a>    <span class="co">// ecological TRMs and (log) TPMs (Stan doesn't like the log of all 0s)</span></span>
<span id="cb31-177"><a href="#cb31-177"></a>    <span class="cf">for</span> (j <span class="cf">in</span> f[i]:(J - <span class="dv">1</span>)) {</span>
<span id="cb31-178"><a href="#cb31-178"></a>      Q[j] = [[ -(psi[<span class="dv">1</span>, j] + phi[<span class="dv">1</span>, j]), psi[<span class="dv">1</span>, j], phi[<span class="dv">1</span>, j] ],</span>
<span id="cb31-179"><a href="#cb31-179"></a>              [ psi[<span class="dv">2</span>, j], -(psi[<span class="dv">2</span>, j] + phi[<span class="dv">2</span>, j]), phi[<span class="dv">2</span>, j] ],</span>
<span id="cb31-180"><a href="#cb31-180"></a>              zeros_row_vector(<span class="dv">3</span>) ];</span>
<span id="cb31-181"><a href="#cb31-181"></a>      P_z[j][<span class="dv">1</span>:<span class="dv">2</span>] = log(matrix_exp(Q[j] * tau[j])[<span class="dv">1</span>:<span class="dv">2</span>]);</span>
<span id="cb31-182"><a href="#cb31-182"></a>      P_z[j][<span class="dv">3</span>] = [ negative_infinity(), negative_infinity(), <span class="dv">0</span> ];</span>
<span id="cb31-183"><a href="#cb31-183"></a>    }</span>
<span id="cb31-184"><a href="#cb31-184"></a>    </span>
<span id="cb31-185"><a href="#cb31-185"></a>    <span class="co">// pathogen detection only needed for observed primaries</span></span>
<span id="cb31-186"><a href="#cb31-186"></a>    delta<span class="fl">.1</span>[f[i]:l[i]] = <span class="dv">1</span> - pow(<span class="dv">1</span> - r[<span class="dv">1</span>], m[i, f[i]:l[i]]);</span>
<span id="cb31-187"><a href="#cb31-187"></a>    delta<span class="fl">.2</span>[f[i]:l[i]] = <span class="dv">1</span> - pow(<span class="dv">1</span> - r[<span class="dv">2</span>], n[i][f[i]:l[i]]);</span>
<span id="cb31-188"><a href="#cb31-188"></a>    </span>
<span id="cb31-189"><a href="#cb31-189"></a>    <span class="co">// initialise log probabilities</span></span>
<span id="cb31-190"><a href="#cb31-190"></a>    Omega = rep_matrix(<span class="dv">0</span>, <span class="dv">3</span>, J);</span>
<span id="cb31-191"><a href="#cb31-191"></a>    </span>
<span id="cb31-192"><a href="#cb31-192"></a>    <span class="co">// for each primary between first and last capture</span></span>
<span id="cb31-193"><a href="#cb31-193"></a>    <span class="cf">for</span> (j <span class="cf">in</span> f[i]:l[i]) {</span>
<span id="cb31-194"><a href="#cb31-194"></a>      <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-195"><a href="#cb31-195"></a></span>
<span id="cb31-196"><a href="#cb31-196"></a>        <span class="co">// fix detection probablity to 1 at secondary of first capture</span></span>
<span id="cb31-197"><a href="#cb31-197"></a>        <span class="dt">vector</span>[<span class="dv">2</span>] p = (j == f[i] &amp;&amp; k == f_k[i]) ? ones_vector(<span class="dv">2</span>) : p_a;</span>
<span id="cb31-198"><a href="#cb31-198"></a>        </span>
<span id="cb31-199"><a href="#cb31-199"></a>        <span class="co">// observation and diagnostic (log) TPMs</span></span>
<span id="cb31-200"><a href="#cb31-200"></a>        P_o = [[ p[<span class="dv">1</span>] * (<span class="dv">1</span> - lambda[<span class="dv">1</span>]), p[<span class="dv">1</span>] * lambda[<span class="dv">1</span>] ],</span>
<span id="cb31-201"><a href="#cb31-201"></a>               [ p[<span class="dv">2</span>] * (<span class="dv">1</span> - delta<span class="fl">.1</span>[j]), p[<span class="dv">2</span>] * delta<span class="fl">.1</span>[j] ]];</span>
<span id="cb31-202"><a href="#cb31-202"></a>        P_y = [[ <span class="dv">1</span> - lambda[<span class="dv">2</span>], lambda[<span class="dv">2</span>] ],</span>
<span id="cb31-203"><a href="#cb31-203"></a>               [ <span class="dv">1</span> - delta<span class="fl">.2</span>[j, k], delta<span class="fl">.2</span>[j, k] ]];</span>
<span id="cb31-204"><a href="#cb31-204"></a>        P_o = log(P_o);</span>
<span id="cb31-205"><a href="#cb31-205"></a>        P_y = log(P_y);</span>
<span id="cb31-206"><a href="#cb31-206"></a></span>
<span id="cb31-207"><a href="#cb31-207"></a>        <span class="co">// increment observation and diagnostic process if detected</span></span>
<span id="cb31-208"><a href="#cb31-208"></a>        <span class="cf">if</span> (q[i, j, k]) {</span>
<span id="cb31-209"><a href="#cb31-209"></a>          Omega[<span class="dv">1</span>:<span class="dv">2</span>, j] += log_prod_exp(P_o, row_sums(P_y[:, y[i, j, k]]));</span>
<span id="cb31-210"><a href="#cb31-210"></a>        } <span class="cf">else</span> {</span>
<span id="cb31-211"><a href="#cb31-211"></a>          Omega[<span class="dv">1</span>:<span class="dv">2</span>, j] += lp_not_detected[<span class="dv">1</span>:<span class="dv">2</span>];</span>
<span id="cb31-212"><a href="#cb31-212"></a>        }</span>
<span id="cb31-213"><a href="#cb31-213"></a>      }</span>
<span id="cb31-214"><a href="#cb31-214"></a>    }</span>
<span id="cb31-215"><a href="#cb31-215"></a></span>
<span id="cb31-216"><a href="#cb31-216"></a>    <span class="co">// increment ecological process up to last capture</span></span>
<span id="cb31-217"><a href="#cb31-217"></a>    Omega[<span class="dv">1</span>:<span class="dv">2</span>, f[i]] += [ log1m_eta[f[i]], log_eta[f[i]] ]';</span>
<span id="cb31-218"><a href="#cb31-218"></a>    <span class="cf">for</span> (j <span class="cf">in</span> (f[i] + <span class="dv">1</span>):l[i]) {</span>
<span id="cb31-219"><a href="#cb31-219"></a>      Omega[<span class="dv">1</span>:<span class="dv">2</span>, j] += log_prod_exp(P_z[j - <span class="dv">1</span>][<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="dv">2</span>]', Omega[<span class="dv">1</span>:<span class="dv">2</span>, j - <span class="dv">1</span>]);</span>
<span id="cb31-220"><a href="#cb31-220"></a>    }</span>
<span id="cb31-221"><a href="#cb31-221"></a>    Omega[<span class="dv">3</span>, l[i]] = negative_infinity();</span>
<span id="cb31-222"><a href="#cb31-222"></a></span>
<span id="cb31-223"><a href="#cb31-223"></a>    <span class="co">// increment ecological and observation process after last capture</span></span>
<span id="cb31-224"><a href="#cb31-224"></a>    <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):J) {</span>
<span id="cb31-225"><a href="#cb31-225"></a>      Omega[:, j] += log_prod_exp(P_z[j - <span class="dv">1</span>]', Omega[:, j - <span class="dv">1</span>]);</span>
<span id="cb31-226"><a href="#cb31-226"></a>      <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-227"><a href="#cb31-227"></a>        Omega[:, j] += lp_not_detected;</span>
<span id="cb31-228"><a href="#cb31-228"></a>      }</span>
<span id="cb31-229"><a href="#cb31-229"></a>    }</span>
<span id="cb31-230"><a href="#cb31-230"></a></span>
<span id="cb31-231"><a href="#cb31-231"></a>    <span class="co">// increment log density</span></span>
<span id="cb31-232"><a href="#cb31-232"></a>    <span class="kw">target +=</span> log_sum_exp(Omega[:, J]);</span>
<span id="cb31-233"><a href="#cb31-233"></a>  }</span>
<span id="cb31-234"><a href="#cb31-234"></a>}</span>
<span id="cb31-235"><a href="#cb31-235"></a></span>
<span id="cb31-236"><a href="#cb31-236"></a><span class="kw">generated quantities</span> {</span>
<span id="cb31-237"><a href="#cb31-237"></a>  <span class="dt">vector</span>[I] log_lik;</span>
<span id="cb31-238"><a href="#cb31-238"></a>  <span class="dt">array</span>[I, J] <span class="dt">int</span> z;</span>
<span id="cb31-239"><a href="#cb31-239"></a>  {</span>
<span id="cb31-240"><a href="#cb31-240"></a>    <span class="dt">matrix</span>[I, J] m;</span>
<span id="cb31-241"><a href="#cb31-241"></a>    <span class="dt">array</span>[I] <span class="dt">matrix</span>[J, K_max] n;</span>
<span id="cb31-242"><a href="#cb31-242"></a>    <span class="dt">int</span> m_idx = <span class="dv">0</span>, n_idx = <span class="dv">0</span>;</span>
<span id="cb31-243"><a href="#cb31-243"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-244"><a href="#cb31-244"></a>      <span class="cf">for</span> (j <span class="cf">in</span> f[i]:J) {</span>
<span id="cb31-245"><a href="#cb31-245"></a>        m_idx += <span class="dv">1</span>;</span>
<span id="cb31-246"><a href="#cb31-246"></a>        m[i, j] = log_m[m_idx];</span>
<span id="cb31-247"><a href="#cb31-247"></a>        <span class="cf">if</span> (j &lt;= l[i]) {</span>
<span id="cb31-248"><a href="#cb31-248"></a>          <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-249"><a href="#cb31-249"></a>            n_idx += <span class="dv">1</span>;</span>
<span id="cb31-250"><a href="#cb31-250"></a>            n[i][j, k] = m[i, j] + log_n_z[n_idx] * sigma[<span class="dv">2</span>];</span>
<span id="cb31-251"><a href="#cb31-251"></a>          }</span>
<span id="cb31-252"><a href="#cb31-252"></a>        }</span>
<span id="cb31-253"><a href="#cb31-253"></a>      }</span>
<span id="cb31-254"><a href="#cb31-254"></a>    }</span>
<span id="cb31-255"><a href="#cb31-255"></a>    m = exp(m);</span>
<span id="cb31-256"><a href="#cb31-256"></a>    n = exp(n);</span>
<span id="cb31-257"><a href="#cb31-257"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, J - <span class="dv">1</span>] psi = exp(rep_matrix(log(psi_a), J - <span class="dv">1</span>) + psi_b * temp);</span>
<span id="cb31-258"><a href="#cb31-258"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, J - <span class="dv">1</span>] psi_p = <span class="dv">1</span> - exp(-psi);</span>
<span id="cb31-259"><a href="#cb31-259"></a>    <span class="dt">row_vector</span>[J - <span class="dv">1</span>] eta = psi_p[<span class="dv">1</span>] ./ col_sums(psi_p);</span>
<span id="cb31-260"><a href="#cb31-260"></a>    <span class="dt">row_vector</span>[J - <span class="dv">1</span>] log_eta = log(eta), log1m_eta = log1m(eta);</span>
<span id="cb31-261"><a href="#cb31-261"></a>    <span class="dt">vector</span>[<span class="dv">3</span>] lp_not_detected = append_row(log1m(p_a), <span class="dv">0</span>);</span>
<span id="cb31-262"><a href="#cb31-262"></a>    <span class="dt">tuple</span>(<span class="dt">row_vector</span>[J], <span class="dt">matrix</span>[J, K_max]) delta;</span>
<span id="cb31-263"><a href="#cb31-263"></a>    <span class="dt">array</span>[J - <span class="dv">1</span>] <span class="dt">matrix</span>[<span class="dv">3</span>, <span class="dv">3</span>] Q, P_z;</span>
<span id="cb31-264"><a href="#cb31-264"></a>    <span class="dt">matrix</span>[<span class="dv">2</span>, <span class="dv">2</span>] P_o, P_y;</span>
<span id="cb31-265"><a href="#cb31-265"></a>    <span class="dt">matrix</span>[<span class="dv">3</span>, J] Omega;</span>
<span id="cb31-266"><a href="#cb31-266"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) {</span>
<span id="cb31-267"><a href="#cb31-267"></a>      <span class="dt">matrix</span>[<span class="dv">2</span>, J - <span class="dv">1</span>] phi;</span>
<span id="cb31-268"><a href="#cb31-268"></a>      phi[<span class="dv">1</span>] = rep_row_vector(phi_a[<span class="dv">1</span>], J - <span class="dv">1</span>);</span>
<span id="cb31-269"><a href="#cb31-269"></a>      phi[<span class="dv">2</span>][f[i]:(J - <span class="dv">1</span>)] = exp(log(phi_a[<span class="dv">2</span>]) + phi_b * m[i, f[i]:(J - <span class="dv">1</span>)]);</span>
<span id="cb31-270"><a href="#cb31-270"></a>      <span class="cf">for</span> (j <span class="cf">in</span> f[i]:(J - <span class="dv">1</span>)) {</span>
<span id="cb31-271"><a href="#cb31-271"></a>        Q[j] = [[ -(psi[<span class="dv">1</span>, j] + phi[<span class="dv">1</span>, j]), psi[<span class="dv">1</span>, j], phi[<span class="dv">1</span>, j] ],</span>
<span id="cb31-272"><a href="#cb31-272"></a>                [ psi[<span class="dv">2</span>, j], -(psi[<span class="dv">2</span>, j] + phi[<span class="dv">2</span>, j]), phi[<span class="dv">2</span>, j] ],</span>
<span id="cb31-273"><a href="#cb31-273"></a>                zeros_row_vector(<span class="dv">3</span>) ];</span>
<span id="cb31-274"><a href="#cb31-274"></a>        P_z[j][<span class="dv">1</span>:<span class="dv">2</span>] = log(matrix_exp(Q[j] * tau[j])[<span class="dv">1</span>:<span class="dv">2</span>]);</span>
<span id="cb31-275"><a href="#cb31-275"></a>        P_z[j][<span class="dv">3</span>] = [ negative_infinity(), negative_infinity(), <span class="dv">0</span> ];</span>
<span id="cb31-276"><a href="#cb31-276"></a>      }</span>
<span id="cb31-277"><a href="#cb31-277"></a>      delta<span class="fl">.1</span>[f[i]:l[i]] = <span class="dv">1</span> - pow(<span class="dv">1</span> - r[<span class="dv">1</span>], m[i, f[i]:l[i]]);</span>
<span id="cb31-278"><a href="#cb31-278"></a>      delta<span class="fl">.2</span>[f[i]:l[i]] = <span class="dv">1</span> - pow(<span class="dv">1</span> - r[<span class="dv">2</span>], n[i][f[i]:l[i]]);</span>
<span id="cb31-279"><a href="#cb31-279"></a>      Omega = rep_matrix(<span class="dv">0</span>, <span class="dv">3</span>, J);</span>
<span id="cb31-280"><a href="#cb31-280"></a>      <span class="cf">for</span> (j <span class="cf">in</span> f[i]:l[i]) {</span>
<span id="cb31-281"><a href="#cb31-281"></a>        <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-282"><a href="#cb31-282"></a>          <span class="dt">vector</span>[<span class="dv">2</span>] p = (j == f[i] &amp;&amp; k == f_k[i]) ? ones_vector(<span class="dv">2</span>) : p_a;</span>
<span id="cb31-283"><a href="#cb31-283"></a>          P_o = [[ p[<span class="dv">1</span>] * (<span class="dv">1</span> - lambda[<span class="dv">1</span>]), p[<span class="dv">1</span>] * lambda[<span class="dv">1</span>] ],</span>
<span id="cb31-284"><a href="#cb31-284"></a>                 [ p[<span class="dv">2</span>] * (<span class="dv">1</span> - delta<span class="fl">.1</span>[j]), p[<span class="dv">2</span>] * delta<span class="fl">.1</span>[j] ]];</span>
<span id="cb31-285"><a href="#cb31-285"></a>          P_y = [[ <span class="dv">1</span> - lambda[<span class="dv">2</span>], lambda[<span class="dv">2</span>] ],</span>
<span id="cb31-286"><a href="#cb31-286"></a>                 [ <span class="dv">1</span> - delta<span class="fl">.2</span>[j, k], delta<span class="fl">.2</span>[j, k] ]];</span>
<span id="cb31-287"><a href="#cb31-287"></a>          P_o = log(P_o);</span>
<span id="cb31-288"><a href="#cb31-288"></a>          P_y = log(P_y);</span>
<span id="cb31-289"><a href="#cb31-289"></a>          </span>
<span id="cb31-290"><a href="#cb31-290"></a>          <span class="co">// forward algorithm for log likelihood</span></span>
<span id="cb31-291"><a href="#cb31-291"></a>          <span class="cf">if</span> (q[i, j, k]) {</span>
<span id="cb31-292"><a href="#cb31-292"></a>            Omega[<span class="dv">1</span>:<span class="dv">2</span>, j] += log_prod_exp(P_o, row_sums(P_y[:, y[i, j, k]]));</span>
<span id="cb31-293"><a href="#cb31-293"></a>          } <span class="cf">else</span> {</span>
<span id="cb31-294"><a href="#cb31-294"></a>            Omega[<span class="dv">1</span>:<span class="dv">2</span>, j] += lp_not_detected[<span class="dv">1</span>:<span class="dv">2</span>];</span>
<span id="cb31-295"><a href="#cb31-295"></a>          }</span>
<span id="cb31-296"><a href="#cb31-296"></a>        }</span>
<span id="cb31-297"><a href="#cb31-297"></a>      }</span>
<span id="cb31-298"><a href="#cb31-298"></a>      Omega[<span class="dv">1</span>:<span class="dv">2</span>, f[i]] += [ log1m_eta[f[i]], log_eta[f[i]] ]';</span>
<span id="cb31-299"><a href="#cb31-299"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (f[i] + <span class="dv">1</span>):l[i]) {</span>
<span id="cb31-300"><a href="#cb31-300"></a>        Omega[<span class="dv">1</span>:<span class="dv">2</span>, j] += log_prod_exp(P_z[j - <span class="dv">1</span>][<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="dv">2</span>]', Omega[<span class="dv">1</span>:<span class="dv">2</span>, j - <span class="dv">1</span>]);</span>
<span id="cb31-301"><a href="#cb31-301"></a>      }</span>
<span id="cb31-302"><a href="#cb31-302"></a>      Omega[<span class="dv">3</span>, l[i]] = negative_infinity();</span>
<span id="cb31-303"><a href="#cb31-303"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (l[i] + <span class="dv">1</span>):J) {</span>
<span id="cb31-304"><a href="#cb31-304"></a>        Omega[:, j] += log_prod_exp(P_z[j - <span class="dv">1</span>]', Omega[:, j - <span class="dv">1</span>]);</span>
<span id="cb31-305"><a href="#cb31-305"></a>        <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span>:K[j]) {</span>
<span id="cb31-306"><a href="#cb31-306"></a>          Omega[:, j] += lp_not_detected;</span>
<span id="cb31-307"><a href="#cb31-307"></a>        }</span>
<span id="cb31-308"><a href="#cb31-308"></a>      }</span>
<span id="cb31-309"><a href="#cb31-309"></a>      log_lik[i] = log_sum_exp(Omega[:, J]);</span>
<span id="cb31-310"><a href="#cb31-310"></a>      </span>
<span id="cb31-311"><a href="#cb31-311"></a>      <span class="co">// backward algorithm for ecological states</span></span>
<span id="cb31-312"><a href="#cb31-312"></a>      z[i, J] = categorical_rng(exp(normalise_log(Omega[:, J])));</span>
<span id="cb31-313"><a href="#cb31-313"></a>      <span class="cf">for</span> (j <span class="cf">in</span> (f[i]) + <span class="dv">1</span>:J) {</span>
<span id="cb31-314"><a href="#cb31-314"></a>        <span class="dt">int</span> jj = J + f[i] - j;</span>
<span id="cb31-315"><a href="#cb31-315"></a>        z[i, jj] = categorical_rng(exp(normalise_log(Omega[:, jj]</span>
<span id="cb31-316"><a href="#cb31-316"></a>                                                     + P_z[jj][:, z[i, jj + <span class="dv">1</span>]])));</span>
<span id="cb31-317"><a href="#cb31-317"></a>      }</span>
<span id="cb31-318"><a href="#cb31-318"></a>    }</span>
<span id="cb31-319"><a href="#cb31-319"></a>  }</span>
<span id="cb31-320"><a href="#cb31-320"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Next I convert the qPCR infection intensities to long format, prepare the data for Stan, and fit the model.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># convert diagnostic infection intensities to long format</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>x_long <span class="ot">&lt;-</span> reshape2<span class="sc">::</span><span class="fu">melt</span>(x, <span class="at">value.name =</span> <span class="st">"x"</span>, <span class="at">varnames =</span> <span class="fu">c</span>(<span class="st">"i"</span>, <span class="st">"j"</span>, <span class="st">"k"</span>, <span class="st">"l"</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>  <span class="fu">drop_na</span>()</span>
<span id="cb32-5"><a href="#cb32-5"></a></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="co"># data for Stan</span></span>
<span id="cb32-7"><a href="#cb32-7"></a>f_k <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span>, I)  <span class="co"># simulated to be first captured in first secondary</span></span>
<span id="cb32-8"><a href="#cb32-8"></a>l <span class="ot">&lt;-</span> <span class="fu">apply</span>(y, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>, min, <span class="at">na.rm =</span> T) <span class="sc">|&gt;</span> <span class="fu">apply</span>(<span class="dv">1</span>, \(y) <span class="fu">max</span>(<span class="fu">which</span>(y <span class="sc">&lt;</span> <span class="dv">3</span>)))</span>
<span id="cb32-9"><a href="#cb32-9"></a>multievent_data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">I =</span> I, <span class="at">J =</span> J, <span class="at">K_max =</span> K_max, <span class="at">L =</span> L, <span class="at">S =</span> <span class="fu">nrow</span>(x_long),</span>
<span id="cb32-10"><a href="#cb32-10"></a>                        <span class="at">K =</span> K, <span class="at">f =</span> f, <span class="at">l =</span> l, <span class="at">f_k =</span> f_k, <span class="at">tau =</span> tau, <span class="at">temp =</span> temp,</span>
<span id="cb32-11"><a href="#cb32-11"></a>                        <span class="at">y =</span> <span class="fu">ifelse</span>(<span class="fu">is.na</span>(y), <span class="dv">3</span>, y),</span>
<span id="cb32-12"><a href="#cb32-12"></a>                        <span class="at">ind =</span> x_long<span class="sc">$</span>i, <span class="at">prim =</span> x_long<span class="sc">$</span>j, <span class="at">sec =</span> x_long<span class="sc">$</span>k,</span>
<span id="cb32-13"><a href="#cb32-13"></a>                        <span class="at">x =</span> x_long<span class="sc">$</span>x)</span>
<span id="cb32-14"><a href="#cb32-14"></a></span>
<span id="cb32-15"><a href="#cb32-15"></a></span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="co"># run HMC</span></span>
<span id="cb32-17"><a href="#cb32-17"></a>fit_multievent <span class="ot">&lt;-</span> multievent<span class="sc">$</span><span class="fu">sample</span>(<span class="at">data =</span> multievent_data, <span class="at">refresh =</span> <span class="dv">0</span>, <span class="at">chains =</span> n_chains, </span>
<span id="cb32-18"><a href="#cb32-18"></a>                                    <span class="at">iter_warmup =</span> n_iter, <span class="at">iter_sampling =</span> n_iter)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running MCMC with 8 parallel chains...</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Chain 2 finished in 434.5 seconds.
Chain 1 finished in 446.2 seconds.
Chain 6 finished in 459.8 seconds.
Chain 4 finished in 472.9 seconds.
Chain 3 finished in 474.1 seconds.
Chain 7 finished in 490.3 seconds.
Chain 8 finished in 621.9 seconds.
Chain 5 finished in 642.4 seconds.

All 8 chains finished successfully.
Mean chain execution time: 505.3 seconds.
Total execution time: 642.7 seconds.</code></pre>
</div>
</div>
</section>
<section id="results-1" class="level3">
<h3 class="anchored" data-anchor-id="results-1">Results</h3>
<p>We’ll visually check the parameter estimates with the simulation input and see that it was recovered well. For what it’s worth, in the paper we showed that the infection dynamics get overestimated significantly (5-fold in <a href="../portfolio/multievent.html">our application</a>) when not accounting for state misclassification.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a>fit_multievent <span class="sc">|&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>  <span class="fu">gather_rvars</span>(phi_a[i], phi_b, psi_a[i], psi_b[i], p_a[i], r[i], lambda[i], mu, sigma[i]) <span class="sc">|&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(phi_a, phi_b, psi_a, psi_b, p_a, r, lambda, mu, sigma),</span>
<span id="cb35-4"><a href="#cb35-4"></a>         <span class="at">parameter =</span> <span class="fu">str_extract</span>(.variable, <span class="st">"^[^_]+"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb35-5"><a href="#cb35-5"></a>           <span class="fu">fct_inorder</span>(),</span>
<span id="cb35-6"><a href="#cb35-6"></a>         <span class="at">process =</span> <span class="fu">case_when</span>(<span class="fu">str_detect</span>(.variable, <span class="st">"phi|psi"</span>) <span class="sc">~</span> <span class="st">"Ecological Process"</span>,</span>
<span id="cb35-7"><a href="#cb35-7"></a>                             <span class="fu">str_detect</span>(.variable, <span class="st">"p_a|r|lambda"</span>) <span class="sc">~</span> <span class="st">"Observation Process"</span>,</span>
<span id="cb35-8"><a href="#cb35-8"></a>                             <span class="at">.default =</span> <span class="st">"Infection Intensities"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb35-9"><a href="#cb35-9"></a>           <span class="fu">fct_inorder</span>(),</span>
<span id="cb35-10"><a href="#cb35-10"></a>         <span class="at">variable =</span> <span class="fu">case_when</span>(<span class="fu">str_detect</span>(.variable, <span class="st">"_a"</span>) <span class="sc">~</span> <span class="fu">str_c</span>(parameter, <span class="st">"["</span>, i, <span class="st">"[alpha]]"</span>),</span>
<span id="cb35-11"><a href="#cb35-11"></a>                              .variable <span class="sc">==</span> <span class="st">"phi_b"</span> <span class="sc">~</span> <span class="st">"phi[beta]"</span>,</span>
<span id="cb35-12"><a href="#cb35-12"></a>                              .variable <span class="sc">==</span> <span class="st">"psi_b"</span> <span class="sc">~</span> <span class="fu">str_c</span>(parameter, <span class="st">"["</span>, i, <span class="st">"[beta]]"</span>),</span>
<span id="cb35-13"><a href="#cb35-13"></a>                              .variable <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"r"</span>, <span class="st">"lambda"</span>, <span class="st">"sigma"</span>) <span class="sc">~</span> <span class="fu">str_c</span>(parameter, <span class="st">"["</span>, i, <span class="st">"]"</span>),</span>
<span id="cb35-14"><a href="#cb35-14"></a>                              <span class="at">.default =</span> .variable) <span class="sc">|&gt;</span> </span>
<span id="cb35-15"><a href="#cb35-15"></a>           <span class="fu">fct_reorder</span>(<span class="fu">as.numeric</span>(parameter))) <span class="sc">|&gt;</span> </span>
<span id="cb35-16"><a href="#cb35-16"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">xdist =</span> .value, <span class="at">y =</span> <span class="fu">fct_rev</span>(variable))) <span class="sc">+</span> </span>
<span id="cb35-17"><a href="#cb35-17"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> process, <span class="at">ncol =</span> <span class="dv">1</span>, <span class="at">scales =</span> <span class="st">"free_y"</span>) <span class="sc">+</span></span>
<span id="cb35-18"><a href="#cb35-18"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="dv">0</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">colour =</span> <span class="st">"#333333"</span>) <span class="sc">+</span></span>
<span id="cb35-19"><a href="#cb35-19"></a>  <span class="fu">stat_pointinterval</span>(<span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>, <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="fl">0.1</span>)) <span class="sc">+</span></span>
<span id="cb35-20"><a href="#cb35-20"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(truth), <span class="at">colour =</span> green, <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">y =</span> <span class="sc">-</span><span class="fl">0.1</span>)) <span class="sc">+</span></span>
<span id="cb35-21"><a href="#cb35-21"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks =</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="fl">0.5</span>), <span class="at">expand =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb35-22"><a href="#cb35-22"></a>  <span class="fu">scale_y_discrete</span>(<span class="at">labels =</span> ggplot2<span class="sc">:::</span>parse_safe) <span class="sc">+</span></span>
<span id="cb35-23"><a href="#cb35-23"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Posterior"</span>, <span class="at">y =</span> <span class="st">"Parameter"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="hmm-in-stan_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Again, we might check to see how well we recovered our latent ecological states, which were completely unobservable from the data. This worked pretty well!</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a>out <span class="ot">&lt;-</span> fit_multievent <span class="sc">|&gt;</span> </span>
<span id="cb36-2"><a href="#cb36-2"></a>  <span class="fu">spread_rvars</span>(z[i, j]) <span class="sc">|&gt;</span> </span>
<span id="cb36-3"><a href="#cb36-3"></a>  <span class="fu">mutate</span>(<span class="at">truth =</span> <span class="fu">c</span>(.env<span class="sc">$</span>z)) <span class="sc">|&gt;</span> </span>
<span id="cb36-4"><a href="#cb36-4"></a>  <span class="fu">left_join</span>(<span class="fu">tibble</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>I, </span>
<span id="cb36-5"><a href="#cb36-5"></a>                   <span class="at">f =</span> f), </span>
<span id="cb36-6"><a href="#cb36-6"></a>            <span class="at">by =</span> <span class="st">"i"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb36-7"><a href="#cb36-7"></a>  <span class="fu">drop_na</span>()</span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="fu">summarise</span>(out, <span class="at">prop_true =</span> <span class="fu">mean</span>(<span class="fu">median</span>(z) <span class="sc">==</span> truth))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 1
  prop_true
      &lt;dbl&gt;
1     0.908</code></pre>
</div>
</div>
<p>One of the main reasons to account for imperfect pathogen detection is to get more realistic estimates of infection prevalence in the population. We can use the full posterior distribution of the latent ecological states from the backward algorithm to estimate the infection prevalence per primary occasion, which here was simulated to be increasing due to dropping temperatures going into austral winter plotted for some fictional dates to show the unequal primary occasion intervals.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a><span class="co"># dates</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>start <span class="ot">&lt;-</span> <span class="fu">ymd</span>(<span class="st">"2020-12-01"</span>)</span>
<span id="cb38-3"><a href="#cb38-3"></a>time_unit <span class="ot">&lt;-</span> <span class="dv">21</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>dates <span class="ot">&lt;-</span> <span class="fu">seq.Date</span>(start, start <span class="sc">+</span> <span class="fu">days</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">round</span>(<span class="fu">sum</span>(tau) <span class="sc">*</span> time_unit)), <span class="at">by =</span> <span class="dv">1</span>)</span>
<span id="cb38-5"><a href="#cb38-5"></a>prim <span class="ot">&lt;-</span> dates[<span class="fu">c</span>(<span class="dv">1</span>, <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>(J <span class="sc">-</span> <span class="dv">1</span>), \(t) <span class="fu">round</span>(<span class="fu">sum</span>(tau[<span class="dv">1</span><span class="sc">:</span>t] <span class="sc">*</span> time_unit))))]</span>
<span id="cb38-6"><a href="#cb38-6"></a></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="co"># plot</span></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="fu">library</span>(posterior)</span>
<span id="cb38-9"><a href="#cb38-9"></a>out <span class="sc">|&gt;</span> </span>
<span id="cb38-10"><a href="#cb38-10"></a>  <span class="fu">left_join</span>(<span class="fu">tibble</span>(<span class="at">j =</span> <span class="dv">1</span><span class="sc">:</span>J, </span>
<span id="cb38-11"><a href="#cb38-11"></a>                   <span class="at">prim =</span> prim), </span>
<span id="cb38-12"><a href="#cb38-12"></a>            <span class="at">by =</span> <span class="st">"j"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb38-13"><a href="#cb38-13"></a>  <span class="fu">summarise</span>(<span class="at">prev =</span> <span class="fu">rvar_sum</span>(z <span class="sc">==</span> <span class="dv">2</span>) <span class="sc">/</span> <span class="fu">rvar_sum</span>(z <span class="sc">&lt;</span> <span class="dv">3</span>),</span>
<span id="cb38-14"><a href="#cb38-14"></a>            <span class="at">truth =</span> <span class="fu">sum</span>(truth <span class="sc">==</span> <span class="dv">2</span>) <span class="sc">/</span> <span class="fu">sum</span>(truth <span class="sc">&lt;</span> <span class="dv">3</span>),</span>
<span id="cb38-15"><a href="#cb38-15"></a>            <span class="at">.by =</span> prim) <span class="sc">|&gt;</span> </span>
<span id="cb38-16"><a href="#cb38-16"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(prim, truth, <span class="at">ydist =</span> prev)) <span class="sc">+</span> </span>
<span id="cb38-17"><a href="#cb38-17"></a>  <span class="fu">stat_pointinterval</span>(<span class="at">point_interval =</span> median_qi, <span class="at">.width =</span> <span class="fl">0.9</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>, <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">x =</span> <span class="fl">0.2</span>)) <span class="sc">+</span></span>
<span id="cb38-18"><a href="#cb38-18"></a>  <span class="fu">geom_point</span>(<span class="at">colour =</span> green, <span class="at">position =</span> <span class="fu">position_nudge</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">2</span>)) <span class="sc">+</span> </span>
<span id="cb38-19"><a href="#cb38-19"></a>  <span class="fu">scale_y_continuous</span>(<span class="at">breaks =</span> <span class="fu">seq</span>(<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="fl">0.2</span>), <span class="at">limits =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">1.001</span>), <span class="at">expand =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb38-20"><a href="#cb38-20"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Primary Occasion"</span>, <span class="at">y =</span> <span class="st">"Infection Prevalence"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="hmm-in-stan_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Thanks for reading if you made it this far. I hope this guide will be useful for ecologists (and others) wanting to transition to gradient-based sampling methods for complex ecological models. I’m sure I’ve some errors somewhere, so if someone finds any or has any questions, please don’t hesitate to reach out.</p>
</section>
</section>
<section id="references" class="level2">




</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-betancourt2018" class="csl-entry" role="listitem">
Betancourt, M. 2018, July 15. <a href="http://arxiv.org/abs/1701.02434">A conceptual introduction to Hamiltonian Monte Carlo</a>. arXiv.
</div>
<div id="ref-burkner2023" class="csl-entry" role="listitem">
Bürkner, P.-C., J. Gabry, M. Kay, and A. Vehtari. 2023. <a href="https://mc-stan.org/posterior/"><span class="nocase">posterior</span>: Tools for working with posterior distributions</a>.
</div>
<div id="ref-carpenter2017" class="csl-entry" role="listitem">
Carpenter, B., A. Gelman, M. D. Hoffman, D. Lee, B. Goodrich, M. Betancourt, M. Brubaker, J. Guo, P. Li, and A. Riddell. 2017. <a href="https://doi.org/10.18637/jss.v076.i01">Stan: A Probabilistic Programming Language</a>. Journal of Statistical Software 76:1–32.
</div>
<div id="ref-cooch2008a" class="csl-entry" role="listitem">
Cooch, E. G., and G. C. White. 2008. Program MARK: A gentle introduction. 19th edition.
</div>
<div id="ref-ergon2018" class="csl-entry" role="listitem">
Ergon, T., Ø. Borgan, C. R. Nater, and Y. Vindenes. 2018. <a href="https://doi.org/10.1111/2041-210X.13059">The utility of mortality hazard rates in population analyses</a>. Methods in Ecology and Evolution 9:2046–2056.
</div>
<div id="ref-gabry2023" class="csl-entry" role="listitem">
Gabry, J., R. Češnovar, and A. Johnson. 2023. <a href="https://mc-stan.org/cmdstanr/">CmdStanR: R interface to <span>“CmdStan”</span></a>. manual.
</div>
<div id="ref-glennie2022" class="csl-entry" role="listitem">
Glennie, R., T. Adam, V. Leos‐Barajas, T. Michelot, T. Photopoulou, and B. T. McClintock. 2022. <a href="https://doi.org/10.1111/2041-210X.13801">Hidden Markov models: Pitfalls and opportunities in ecology</a>. Methods in Ecology and Evolution:2041–210X.13801.
</div>
<div id="ref-goulet2021" class="csl-entry" role="listitem">
Goulet, V., C. Dutang, M. Maechler, D. Firth, M. Shapira, and M. Stadelmann. 2021. <a href="https://CRAN.R-project.org/package=expm">Package <span class="nocase"><span>“expm”</span></span></a>.
</div>
<div id="ref-hoffman2014" class="csl-entry" role="listitem">
Hoﬀman, M. D., and A. Gelman. 2014. The No-U-Turn Sampler: Adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research 15:1593–1623.
</div>
<div id="ref-hollanders2022c" class="csl-entry" role="listitem">
Hollanders, M., and J. A. Royle. 2022. <a href="https://doi.org/10.1111/2041-210X.13993">Know what you don’t know: Embracing state uncertainty in disease-structured multistate models</a>. Methods in Ecology and Evolution 13:2827–2837.
</div>
<div id="ref-kay2022a" class="csl-entry" role="listitem">
Kay, M. 2022. <a href="https://doi.org/10.5281/zenodo.1308151"><span class="nocase">tidybayes</span>: Tidy data and geoms for Bayesian models</a>.
</div>
<div id="ref-kery2015" class="csl-entry" role="listitem">
Kéry, M., and J. A. Royle. 2015. Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. Academic Press.
</div>
<div id="ref-kery2020a" class="csl-entry" role="listitem">
Kéry, M., and J. A. Royle. 2020. Applied hierarchical modeling in ecology: Analysis of distribution, abundance and species richness in r and BUGS: Volume 2: Dynamic and advanced models. Academic Press.
</div>
<div id="ref-neal1994" class="csl-entry" role="listitem">
Neal, R. M. 1994. <a href="https://doi.org/10.1006/jcph.1994.1054">An improved acceptance procedure for the hybrid Monte Carlo algorithm</a>. Journal of Computational Physics 111:194–203.
</div>
<div id="ref-pollock1982" class="csl-entry" role="listitem">
Pollock, K. H. 1982. <a href="https://doi.org/10.2307/3808568">A capture-recapture design robust to unequal probability of capture</a>. The Journal of Wildlife Management 46:752–757.
</div>
<div id="ref-rcoreteam2023" class="csl-entry" role="listitem">
R Core Team. 2023. <a href="https://www.R-project.org/">R: A language and environment for statistical computing</a>. R Foundation for Statistical Computing, Vienna, Austria.
</div>
<div id="ref-royle2006" class="csl-entry" role="listitem">
Royle, J. A., and W. A. Link. 2006. <a href="https://doi.org/10.1890/0012-9658(2006)87[835:GSOMAF]2.0.CO;2">Generalized site occupancy models allowing for false positive and false negative errors</a>. Ecology 87:835–841.
</div>
<div id="ref-scheele2019a" class="csl-entry" role="listitem">
Scheele, B. C., F. Pasmans, L. Skerratt, L. Berger, A. Martel, W. Beukema, A. A. Acevedo, P. A. Burrowes, T. Carvalho, A. Catenazzi, C. N. Foster, P. Frías-Álvarez, T. W. J. Garner, B. Gratwicke, J. M. Guayasamin, M. Hirschfeld, J. E. Kolby, T. A. Kosch, A. V. Longo, R. Maneyro, C. A. McDonald, J. R. Mendelson III, P. Palacios-Rodriguez, G. Parra-Olea, C. L. Richards-Zawacki, M.-O. Rödel, S. M. Rovito, C. Soto-Azat, L. F. Toledo, J. Voyles, C. Weldon, S. M. Whitfield, M. Wilkinson, K. R. Zamudio, and S. Canessa. 2019. <a href="https://doi.org/10.1126/science.aav0379">Amphibian fungal panzootic causes catastrophic and ongoing loss of biodiversity</a>. Science 363:1459–1463.
</div>
<div id="ref-devalpine2017" class="csl-entry" role="listitem">
de Valpine, P., D. Turek, C. J. Paciorek, C. Anderson-Bergman, D. T. Lang, and R. Bodik. 2017. <a href="https://doi.org/10.1080/10618600.2016.1172487">Programming with models: Writing statistical algorithms for general model structures with NIMBLE</a>. Journal of Computational and Graphical Statistics 26:403–413.
</div>
<div id="ref-vehtari2023" class="csl-entry" role="listitem">
Vehtari, A., J. Gabry, M. Magnusson, Y. Yao, P.-C. Bürkner, T. Paananen, and A. Gelman. 2023. <a href="https://mc-stan.org/loo/"><span class="nocase">loo</span>: Efficient leave-one-out cross-validation and WAIC for Bayesian models</a>.
</div>
<div id="ref-wickham2016" class="csl-entry" role="listitem">
Wickham, H. 2016. <a href="https://ggplot2.tidyverse.org"><span class="nocase">ggplot2</span>: Elegant graphics for data analysis</a>. Springer-Verlag New York.
</div>
<div id="ref-wickham2019" class="csl-entry" role="listitem">
Wickham, H., M. Averick, J. Bryan, W. Chang, L. D. McGowan, R. François, G. Grolemund, A. Hayes, L. Henry, J. Hester, M. Kuhn, T. L. Pedersen, E. Miller, S. M. Bache, K. Müller, J. Ooms, D. Robinson, D. P. Seidel, V. Spinu, K. Takahashi, D. Vaughan, C. Wilke, K. Woo, and H. Yutani. 2019. <a href="https://doi.org/10.21105/joss.01686">Welcome to the <span class="nocase">tidyverse</span></a>. Journal of Open Source Software 4:1686.
</div>
<div id="ref-youngflesh2018" class="csl-entry" role="listitem">
Youngflesh, C. 2018. <a href="https://doi.org/10.21105/joss.00640">MCMCvis: tools to visualize, manipulate, and summarize MCMC output</a>. Journal of Open Source Software 3:640.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>See <span class="citation" data-cites="betancourt2018">Betancourt (<a href="#ref-betancourt2018" role="doc-biblioref">2018</a>)</span> for a deep dive into HMC.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>According to the <a href="https://mc-stan.org/docs/stan-users-guide/latent-discrete.html#rao-blackwell.section">Stan User’s Guide</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Summing probabilities on the log scale requires exponentiating the log probabilities, summing them, and taking the logarithm once again.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>There are some identifiability issues here, reflected in the posterior correlations that exist between the intercepts and slopes.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/quantecol\.com\.au");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Quantecol | 53 Bentinck Street, Ballina NSW, Australia | ABN: 90 710 874 314</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>